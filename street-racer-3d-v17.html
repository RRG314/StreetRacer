<!DOCTYPE html>
<html><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Street Racer 3D</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;500;700&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0a0f;overflow:hidden;font-family:'Rajdhani',sans-serif}

/* Title Screen */
#titleScreen{position:fixed;inset:0;background:linear-gradient(135deg,#0a0a0f,#1a1a2f,#0a0a0f);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:200}
#titleScreen.hidden{display:none}
.logo{font-family:Orbitron,monospace;font-size:52px;font-weight:900;color:#0fc;text-shadow:0 0 20px #0fc,0 0 40px #0fc;letter-spacing:6px;animation:titlePulse 2s ease-in-out infinite}
.sub{font-size:18px;color:rgba(255,255,255,0.5);letter-spacing:6px;margin:8px 0 30px}
@keyframes titlePulse{0%,100%{text-shadow:0 0 20px #0fc,0 0 40px #0fc}50%{text-shadow:0 0 30px #0fc,0 0 60px #0fc,0 0 100px rgba(0,255,200,0.6)}}

/* Menu Container with Tabs */
.menu-container{background:rgba(0,0,0,0.6);border:1px solid rgba(0,255,200,0.2);border-radius:14px;width:500px;max-width:95vw;max-height:80vh;display:flex;flex-direction:column}
.tab-nav{display:flex;border-bottom:1px solid rgba(0,255,200,0.2);flex-shrink:0}
.tab-btn{flex:1;background:transparent;border:none;padding:14px;font-family:Orbitron;font-size:11px;color:rgba(255,255,255,0.4);cursor:pointer;transition:all 0.3s;text-transform:uppercase;letter-spacing:2px;position:relative}
.tab-btn:hover{color:rgba(255,255,255,0.7);background:rgba(255,255,255,0.05)}
.tab-btn.active{color:#0fc;background:rgba(0,255,200,0.1)}
.tab-btn.active::after{content:'';position:absolute;bottom:0;left:0;right:0;height:2px;background:#0fc}
.tab-content{display:none;padding:18px;overflow-y:auto;flex:1}
.tab-content.active{display:block}

/* Location Grid */
.loc-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
.loc{background:rgba(0,0,0,0.4);border:2px solid rgba(0,255,200,0.2);border-radius:8px;padding:12px;cursor:pointer;text-align:center;transition:all 0.2s}
.loc:hover{border-color:rgba(0,255,200,0.5);background:rgba(0,255,200,0.05)}
.loc.sel{border-color:#0fc;background:rgba(0,255,200,0.15);box-shadow:0 0 15px rgba(0,255,200,0.2)}
.loc-name{color:#0fc;font-family:Orbitron;font-size:13px}
.loc-region{color:rgba(255,255,255,0.5);font-size:11px}
.loc.custom{border-color:rgba(255,200,50,0.3)}
.loc.custom:hover{border-color:rgba(255,200,50,0.6);background:rgba(255,200,50,0.1)}
.loc.custom.sel{border-color:#fc0;background:rgba(255,200,50,0.2);box-shadow:0 0 15px rgba(255,200,50,0.2)}
.loc.custom .loc-name{color:#fc0}

/* Custom Location Panel */
#customPanel{display:none;margin-top:14px;padding:14px;background:rgba(0,0,0,0.5);border:1px solid rgba(255,200,50,0.3);border-radius:8px}
#customPanel.show{display:block}
.custom-title{font-family:Orbitron;font-size:12px;color:#fc0;margin-bottom:12px;text-align:center}
.custom-row{margin-bottom:12px}
.custom-row label{display:block;font-size:11px;color:rgba(255,255,255,0.6);margin-bottom:6px}
.search-row{display:flex;gap:8px}
.search-row input{flex:1;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.2);border-radius:6px;padding:10px;color:#fff;font-size:13px}
.search-row input:focus{outline:none;border-color:#fc0}
.search-btn{background:linear-gradient(135deg,#fc0,#f90);border:none;border-radius:6px;padding:10px 14px;color:#000;font-weight:bold;cursor:pointer}
.search-btn:hover{transform:scale(1.05)}
#searchStatus{font-size:10px;margin-top:6px;min-height:14px;color:rgba(255,255,255,0.5)}
#searchStatus.success{color:#0f8}
#searchStatus.error{color:#f66}
.divider{text-align:center;margin:12px 0;position:relative}
.divider::before{content:'';position:absolute;left:0;right:0;top:50%;height:1px;background:rgba(255,255,255,0.2)}
.divider span{background:rgba(0,0,0,0.5);padding:0 10px;position:relative;color:rgba(255,255,255,0.4);font-size:11px}
.coords-row{display:flex;gap:10px}
.coords-row input{flex:1;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.2);border-radius:6px;padding:10px;color:#fff;font-size:13px}
.coords-row input:focus{outline:none;border-color:#fc0}

/* Game Mode */
.mode-grid{display:flex;flex-direction:column;gap:10px}
.mode{display:flex;align-items:center;gap:14px;background:rgba(0,0,0,0.4);border:2px solid rgba(255,255,255,0.15);border-radius:10px;padding:14px;cursor:pointer;transition:all 0.2s}
.mode:hover{border-color:rgba(255,255,255,0.3);background:rgba(255,255,255,0.05)}
.mode.sel{border-color:#f36;background:rgba(255,51,102,0.15);box-shadow:0 0 15px rgba(255,51,102,0.2)}
.mode-icon{font-size:26px;width:40px;text-align:center}
.mode-name{color:#fff;font-family:Orbitron;font-size:13px}
.mode-desc{color:rgba(255,255,255,0.5);font-size:11px}
.mode-check{width:18px;height:18px;border:2px solid rgba(255,255,255,0.2);border-radius:50%;margin-left:auto;display:flex;align-items:center;justify-content:center;font-size:10px;color:transparent}
.mode.sel .mode-check{border-color:#f36;color:#f36}

/* Controls Tab */
.ctrl-grid{display:grid;grid-template-columns:1fr 1fr;gap:6px 16px}
.ctrl-section{grid-column:1/-1;font-family:Orbitron;font-size:10px;color:#f36;text-transform:uppercase;letter-spacing:1px;margin-top:10px;padding-bottom:4px;border-bottom:1px solid rgba(255,51,102,0.2)}
.ctrl-section:first-child{margin-top:0}
.ctrl-row{display:flex;align-items:center;gap:8px;padding:4px 0}
.ctrl-key{background:rgba(0,255,200,0.15);border:1px solid rgba(0,255,200,0.3);border-radius:4px;padding:3px 7px;font-family:Orbitron;font-size:9px;color:#0fc}
.ctrl-action{font-size:11px;color:rgba(255,255,255,0.7)}

/* Start Button */
.start-section{padding:14px 18px;border-top:1px solid rgba(0,255,200,0.2);flex-shrink:0;background:rgba(0,0,0,0.3)}
.startBtn{width:100%;background:linear-gradient(135deg,#0fc,#0a8);border:none;border-radius:10px;padding:16px;font-family:Orbitron;font-size:15px;font-weight:700;color:#000;cursor:pointer;letter-spacing:4px;text-transform:uppercase}
.startBtn:hover{box-shadow:0 0 25px rgba(0,255,200,0.4);transform:scale(1.01)}

/* HUD */
#hud{position:fixed;top:10px;left:10px;z-index:100;display:none}
#hud.show{display:block}
.hud-box{background:rgba(0,0,0,0.8);border:1px solid rgba(0,255,200,0.3);border-radius:8px;padding:12px;min-width:140px}
#speed{font-family:Orbitron;font-size:36px;color:#0fc}
#speed.fast{color:#f36}
.hud-label{font-size:10px;color:rgba(255,255,255,0.5)}
#street{font-family:Orbitron;font-size:10px;color:#fff;margin-top:8px;border-top:1px solid rgba(255,255,255,0.1);padding-top:8px}
#boostBar{width:100%;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;margin-top:6px;overflow:hidden}
#boostFill{height:100%;width:100%;background:linear-gradient(90deg,#0fc,#0f8);transition:width 0.1s}
#boostFill.active{background:linear-gradient(90deg,#f80,#fc0)}
.indicators{display:flex;gap:8px;margin-top:6px;font-size:9px}
.ind{color:rgba(255,255,255,0.3)}
.ind.on{color:#0fc}
.ind.warn{color:#f36}
#offRoadWarn{position:fixed;inset:0;pointer-events:none;border:4px solid transparent;z-index:50;transition:border-color 0.2s}
#offRoadWarn.active{border-color:rgba(255,100,50,0.6);animation:pulse 0.5s infinite}
@keyframes pulse{0%,100%{border-color:rgba(255,100,50,0.6)}50%{border-color:rgba(255,100,50,0.2)}}
#minimap{position:fixed;bottom:10px;left:10px;width:150px;height:150px;background:rgba(0,0,0,0.85);border:1px solid rgba(0,255,200,0.3);border-radius:8px;z-index:100;display:none}
#minimap.show{display:block}
#modeHud{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);border:1px solid rgba(0,255,200,0.3);border-radius:8px;padding:8px 20px;z-index:100;text-align:center;display:none}
#modeHud.show{display:block}
#modeTitle{font-family:Orbitron;font-size:11px;color:#f36}
#modeTimer{font-family:Orbitron;font-size:22px;color:#0fc}
#modeInfo{font-size:10px;color:rgba(255,255,255,0.5)}
#police{position:fixed;top:10px;right:10px;background:rgba(0,0,0,0.8);border:1px solid #f36;border-radius:6px;padding:6px 12px;color:#f36;font-family:Orbitron;font-size:12px;z-index:100;display:none}
#police.show{display:block}
#floatMenu{position:fixed;bottom:10px;right:10px;z-index:100;display:none}
#floatMenu.show{display:block}
#floatBtn{width:40px;height:40px;border-radius:50%;background:rgba(0,0,0,0.8);border:2px solid #0fc;color:#0fc;font-size:18px;cursor:pointer}
.floatItems{position:absolute;bottom:50px;right:0;display:none;flex-direction:column;gap:4px}
#floatMenu.open .floatItems{display:flex}
.floatItem{background:rgba(0,0,0,0.9);border:1px solid rgba(0,255,200,0.4);border-radius:4px;padding:6px 10px;color:#0fc;font-size:10px;cursor:pointer;white-space:nowrap}
.floatItem:hover{background:rgba(0,255,200,0.2)}
.floatItem.on{background:rgba(0,255,200,0.3)}
.floatItem.recording{background:rgba(255,50,50,0.3);border-color:#f55}
#controlsTab{position:fixed;bottom:10px;left:180px;background:rgba(0,0,0,0.8);border:1px solid rgba(0,255,200,0.3);border-radius:6px;z-index:100;display:none;font-size:11px;color:#fff;max-width:200px}
#controlsTab.show{display:block}
#ctrlHeader{padding:8px 12px;cursor:pointer;color:#0fc;font-family:Orbitron}
#ctrlContent{padding:8px 12px;border-top:1px solid rgba(0,255,200,0.2);line-height:1.6}
#ctrlContent.hidden{display:none}
#coords{position:fixed;bottom:175px;left:10px;background:rgba(0,0,0,0.7);border:1px solid rgba(0,255,200,0.2);border-radius:4px;padding:6px 10px;font-size:10px;color:rgba(255,255,255,0.7);z-index:100;display:none}
#coords.show{display:block}
#loading{position:fixed;inset:0;background:rgba(0,0,0,0.95);display:none;align-items:center;justify-content:center;flex-direction:column;z-index:300;cursor:pointer}
#loading.show{display:flex}
.spinner{width:36px;height:36px;border:3px solid rgba(0,255,200,0.2);border-top-color:#0fc;border-radius:50%;animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
#loadText{color:#0fc;font-family:Orbitron;margin-top:12px;font-size:13px}
#pauseScreen{position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;flex-direction:column;z-index:250}
#pauseScreen.show{display:flex}
.pauseTitle{font-family:Orbitron;font-size:32px;color:#0fc;margin-bottom:20px}
.pauseBtn{background:rgba(0,0,0,0.5);border:2px solid rgba(0,255,200,0.3);border-radius:6px;padding:10px 30px;color:#0fc;font-family:Orbitron;font-size:12px;cursor:pointer;margin:5px;min-width:160px}
.pauseBtn:hover{border-color:#0fc;background:rgba(0,255,200,0.1)}
#resultScreen{position:fixed;inset:0;background:rgba(0,0,0,0.9);display:none;align-items:center;justify-content:center;z-index:260}
#resultScreen.show{display:flex}
.resultBox{background:rgba(0,20,20,0.95);border:2px solid #0fc;border-radius:10px;padding:25px 40px;text-align:center}
#resultTitle{font-family:Orbitron;font-size:24px;color:#0fc;margin-bottom:10px}
#resultStats{color:rgba(255,255,255,0.7);margin-bottom:15px;line-height:1.6}
#caughtScreen{position:fixed;inset:0;background:rgba(255,0,0,0.2);display:none;align-items:center;justify-content:center;z-index:270}
#caughtScreen.show{display:flex}
.caughtBox{background:rgba(0,0,0,0.9);border:3px solid #f36;border-radius:10px;padding:25px;text-align:center}
.caughtTitle{font-family:Orbitron;font-size:28px;color:#f36;margin-bottom:10px}
.caughtText{color:rgba(255,255,255,0.7);margin-bottom:15px}
.caughtBtn{background:linear-gradient(135deg,#f36,#c25);border:none;border-radius:6px;padding:10px 25px;color:#fff;font-family:Orbitron;cursor:pointer}
</style>
</head>
<body>
<div id="titleScreen">
<div class="logo">STREET RACER</div>
<div class="sub">3D EDITION</div>
<div class="menu-container">
<div class="tab-nav">
<button class="tab-btn active" data-tab="location">Location</button>
<button class="tab-btn" data-tab="mode">Game Mode</button>
<button class="tab-btn" data-tab="controls">Controls</button>
</div>
<div class="tab-content active" id="tab-location">
<div class="loc-grid">
<div class="loc sel" data-loc="baltimore"><div class="loc-name">Baltimore</div><div class="loc-region">Maryland, USA</div></div>
<div class="loc" data-loc="hollywood"><div class="loc-name">Hollywood</div><div class="loc-region">California, USA</div></div>
<div class="loc" data-loc="newyork"><div class="loc-name">New York</div><div class="loc-region">New York, USA</div></div>
<div class="loc" data-loc="miami"><div class="loc-name">Miami</div><div class="loc-region">Florida, USA</div></div>
<div class="loc" data-loc="tokyo"><div class="loc-name">Tokyo</div><div class="loc-region">Japan</div></div>
<div class="loc" data-loc="monaco"><div class="loc-name">Monaco</div><div class="loc-region">Monte Carlo</div></div>
<div class="loc" data-loc="nurburgring"><div class="loc-name">N√ºrburgring</div><div class="loc-region">Germany</div></div>
<div class="loc" data-loc="lasvegas"><div class="loc-name">Las Vegas</div><div class="loc-region">Nevada, USA</div></div>
<div class="loc" data-loc="london"><div class="loc-name">London</div><div class="loc-region">United Kingdom</div></div>
<div class="loc" data-loc="paris"><div class="loc-name">Paris</div><div class="loc-region">France</div></div>
<div class="loc" data-loc="dubai"><div class="loc-name">Dubai</div><div class="loc-region">UAE</div></div>
<div class="loc custom" data-loc="custom"><div class="loc-name">üåç Custom</div><div class="loc-region">Any Location</div></div>
</div>
<div id="customPanel">
<div class="custom-title">Enter Your Location</div>
<div class="custom-row">
<label>Search by City Name</label>
<div class="search-row">
<input type="text" id="citySearch" placeholder="e.g. Paris, France">
<button class="search-btn" id="searchBtn">üîç</button>
</div>
<div id="searchStatus">Tip: Include country for better results</div>
</div>
<div class="divider"><span>OR</span></div>
<div class="custom-row">
<label>Enter Coordinates (get from Google Maps)</label>
<div class="coords-row">
<input type="number" id="customLat" placeholder="Latitude" step="0.0001">
<input type="number" id="customLon" placeholder="Longitude" step="0.0001">
</div>
</div>
</div>
</div>
<div class="tab-content" id="tab-mode">
<div class="mode-grid">
<div class="mode sel" data-mode="free"><div class="mode-icon">üöó</div><div><div class="mode-name">Free Roam</div><div class="mode-desc">Explore the city at your own pace</div></div><div class="mode-check">‚úì</div></div>
<div class="mode" data-mode="trial"><div class="mode-icon">‚è±Ô∏è</div><div><div class="mode-name">Time Trial</div><div class="mode-desc">Race to the destination as fast as you can</div></div><div class="mode-check">‚úì</div></div>
<div class="mode" data-mode="checkpoint"><div class="mode-icon">üèÅ</div><div><div class="mode-name">Checkpoints</div><div class="mode-desc">Collect all markers scattered across the map</div></div><div class="mode-check">‚úì</div></div>
</div>
</div>
<div class="tab-content" id="tab-controls">
<div class="ctrl-grid">
<div class="ctrl-section">Driving</div>
<div class="ctrl-row"><span class="ctrl-key">W</span><span class="ctrl-key">‚Üë</span><span class="ctrl-action">Accelerate</span></div>
<div class="ctrl-row"><span class="ctrl-key">S</span><span class="ctrl-key">‚Üì</span><span class="ctrl-action">Brake/Reverse</span></div>
<div class="ctrl-row"><span class="ctrl-key">A</span><span class="ctrl-key">‚Üê</span><span class="ctrl-action">Turn Left</span></div>
<div class="ctrl-row"><span class="ctrl-key">D</span><span class="ctrl-key">‚Üí</span><span class="ctrl-action">Turn Right</span></div>
<div class="ctrl-row"><span class="ctrl-key">Space</span><span class="ctrl-action">Handbrake</span></div>
<div class="ctrl-row"><span class="ctrl-key">Ctrl</span><span class="ctrl-action">Boost</span></div>
<div class="ctrl-section">Camera</div>
<div class="ctrl-row"><span class="ctrl-key">C</span><span class="ctrl-action">Cycle Camera</span></div>
<div class="ctrl-row"><span class="ctrl-key">V</span><span class="ctrl-action">Look Back</span></div>
<div class="ctrl-row"><span class="ctrl-key">Esc</span><span class="ctrl-action">Pause</span></div>
<div class="ctrl-section">Special</div>
<div class="ctrl-row"><span class="ctrl-key">Shift</span><span class="ctrl-action">Off-Road Mode</span></div>
<div class="ctrl-row"><span class="ctrl-key">R</span><span class="ctrl-action">Record Track</span></div>
<div class="ctrl-row"><span class="ctrl-key">N</span><span class="ctrl-action">Next City</span></div>
</div>
</div>
<div class="start-section"><button class="startBtn" id="startBtn">START GAME</button></div>
</div>
</div>
<div id="hud"><div class="hud-box">
<div id="speed">0</div>
<div class="hud-label">MPH <span style="margin-left:6px">LIMIT <span id="limit">--</span></span></div>
<div id="boostBar"><div id="boostFill"></div></div>
<div id="street">Loading...</div>
<div class="indicators"><span class="ind" id="indBrake">BRK</span><span class="ind" id="indBoost">BOOST</span><span class="ind" id="indDrift">DRIFT</span><span class="ind" id="indOff">OFF</span></div>
</div></div>
<div id="coords">--</div>
<div id="offRoadWarn"></div>
<canvas id="minimap" width="150" height="150"></canvas>
<div id="modeHud"><div id="modeTitle">Free Roam</div><div id="modeTimer">--:--</div><div id="modeInfo"></div></div>
<div id="police">üíî 0/3</div>
<div id="floatMenu"><button id="floatBtn">‚ò∞</button><div class="floatItems">
<div class="floatItem" id="fHome">üè† Menu</div>
<div class="floatItem" id="fNextCity">üìç Next City</div>
<div class="floatItem" id="fPolice">üöî Police</div>
<div class="floatItem" id="fRespawn">üéØ Respawn</div>
<div class="floatItem" id="fRespawnRand">üé≤ Random Spawn</div>
<div class="floatItem" id="fTrack">üèÅ Record Track</div>
<div class="floatItem" id="fEraseTrack">üóëÔ∏è Erase Track</div>
</div></div>
<div id="controlsTab"><div id="ctrlHeader">üéÆ Controls ‚ñº</div><div id="ctrlContent" class="hidden">
<b>Driving:</b> WASD/Arrows<br>
<b>Handbrake:</b> Space<br>
<b>Boost:</b> Ctrl<br>
<b>Off-road:</b> Shift<br>
<b>Camera:</b> C / V<br>
<b>Track:</b> R<br>
<b>Pause:</b> Esc
</div></div>
<div id="loading"><div class="spinner"></div><div id="loadText">Loading...</div></div>
<div id="pauseScreen"><div class="pauseTitle">PAUSED</div><button class="pauseBtn" id="resumeBtn">Resume</button><button class="pauseBtn" id="restartBtn">Restart</button><button class="pauseBtn" id="menuBtn">Main Menu</button></div>
<div id="resultScreen"><div class="resultBox"><div id="resultTitle">Complete!</div><div id="resultStats"></div><button class="pauseBtn" id="againBtn">Play Again</button><button class="pauseBtn" id="freeBtn">Free Roam</button><button class="pauseBtn" id="resMenuBtn">Menu</button></div></div>
<div id="caughtScreen"><div class="caughtBox"><div class="caughtTitle">üöî BUSTED!</div><div class="caughtText">You've been caught!</div><button class="caughtBtn" id="caughtBtn">Try Again</button></div></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const LOCS = {
    baltimore: { name: 'Baltimore', lat: 39.2904, lon: -76.6122 },
    hollywood: { name: 'Hollywood', lat: 34.0928, lon: -118.3287 },
    newyork: { name: 'New York', lat: 40.7580, lon: -73.9855 },
    miami: { name: 'Miami', lat: 25.7617, lon: -80.1918 },
    tokyo: { name: 'Tokyo', lat: 35.6762, lon: 139.6503 },
    monaco: { name: 'Monaco', lat: 43.7384, lon: 7.4246 },
    nurburgring: { name: 'N√ºrburgring', lat: 50.3356, lon: 6.9475 },
    lasvegas: { name: 'Las Vegas', lat: 36.1699, lon: -115.1398 },
    london: { name: 'London', lat: 51.5074, lon: -0.1278 },
    paris: { name: 'Paris', lat: 48.8566, lon: 2.3522 },
    dubai: { name: 'Dubai', lat: 25.2048, lon: 55.2708 }
};
const locKeys = Object.keys(LOCS);
const SCALE = 100000;
let LOC = { lat: 39.2904, lon: -76.6122 };
let customLoc = null;
const geoToWorld = (lat, lon) => ({ x: (lon - LOC.lon) * SCALE * Math.cos(LOC.lat * Math.PI / 180), z: -(lat - LOC.lat) * SCALE });

const car = { x:0, z:0, angle:0, speed:0, vx:0, vz:0, grip:1, onRoad:true, road:null, boost:false, boostTime:0, boostReady:true, driftAngle:0 };
const keys = {};
let roads = [], roadMeshes = [], buildingMeshes = [], scene, camera, renderer, carMesh, wheelMeshes = [];
let gameStarted = false, paused = false, gameMode = 'free', gameTimer = 0, camMode = 0, selLoc = 'baltimore';
let policeOn = false, police = [], policeMeshes = [], policeHits = 0;
let checkpoints = [], cpMeshes = [], cpCollected = 0;
let destination = null, destMesh = null, trialDone = false;
let customTrack = [], trackMesh = null, isRecording = false;
let roadGrid = {}, roadGridSize = 50; // Spatial hash for fast road lookup
const mctx = document.getElementById('minimap').getContext('2d');

const CFG = { 
    maxSpd: 240, offMax: 40, accel: 45, boostAccel: 180, brake: 200, friction: 40, offFriction: 200,
    boostMax: 280, boostDur: 2,
    brakeForce: 3,       // How fast Space brakes
    // Grip settings
    gripRoad: 0.92,      // Normal road grip
    gripOff: 0.6,        // Off-road grip
    gripBrake: 0.5,      // Grip while braking hard
    gripDrift: 0.35,     // Grip while brake+turning (drift mode!)
    driftRec: 5,         // How fast car realigns (lower = longer drifts)
    // Turn settings
    turnLow: 3.0,        // Turn rate at low speed
    turnHigh: 1.5,       // Turn rate at high speed  
    turnMin: 20,         // Speed where turn rate starts reducing
    cpRadius: 25, trialTime: 120, policeSpd: 180, policeAccel: 80, policeDist: 800 
};

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 300, 1200);
    camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 1500);
    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    document.body.prepend(renderer.domElement);
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const sun = new THREE.DirectionalLight(0xffffff, 0.6);
    sun.position.set(80, 150, 80);
    scene.add(sun);
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000), new THREE.MeshLambertMaterial({ color: 0x2d5a3d }));
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);
    
    // Create car with wheels
    carMesh = new THREE.Group();
    const bodyMat = new THREE.MeshLambertMaterial({ color: 0xff3366 });
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 3.5), bodyMat);
    body.position.y = 0.5;
    carMesh.add(body);
    const roof = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.4, 1.5), bodyMat);
    roof.position.set(0, 0.95, -0.2);
    carMesh.add(roof);
    // Windshield
    const glassMat = new THREE.MeshLambertMaterial({ color: 0x88ccff, transparent: true, opacity: 0.6 });
    const windshield = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.35, 0.1), glassMat);
    windshield.position.set(0, 0.85, 0.55);
    windshield.rotation.x = -0.3;
    carMesh.add(windshield);
    // Wheels - simplified
    const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 8);
    const wheelMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
    const wheelPositions = [[-0.85, 0.35, 1.1], [0.85, 0.35, 1.1], [-0.85, 0.35, -1.1], [0.85, 0.35, -1.1]];
    wheelMeshes = [];
    wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
        wheel.rotation.z = Math.PI / 2;
        wheel.position.set(...pos);
        carMesh.add(wheel);
        wheelMeshes.push(wheel);
    });
    // Headlights
    const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffcc });
    const hl1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.05), lightMat);
    hl1.position.set(-0.55, 0.45, 1.76);
    carMesh.add(hl1);
    const hl2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.05), lightMat);
    hl2.position.set(0.55, 0.45, 1.76);
    carMesh.add(hl2);
    // Taillights
    const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const tl1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.05), tailMat);
    tl1.position.set(-0.55, 0.45, -1.76);
    carMesh.add(tl1);
    const tl2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.15, 0.05), tailMat);
    tl2.position.set(0.55, 0.45, -1.76);
    carMesh.add(tl2);
    
    scene.add(carMesh);
    addEventListener('resize', () => { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
    addEventListener('keydown', e => { keys[e.code] = true; onKey(e.code); });
    addEventListener('keyup', e => keys[e.code] = false);
    setupUI();
    renderLoop();
}

function onKey(code) {
    if (!gameStarted) return;
    if (code === 'KeyC') camMode = (camMode + 1) % 3;
    if (code === 'KeyR') toggleTrackRecording();
    if (code === 'KeyN') nextCity();
    if (code === 'Escape' && !document.getElementById('resultScreen').classList.contains('show') && !document.getElementById('caughtScreen').classList.contains('show')) {
        paused = !paused;
        document.getElementById('pauseScreen').classList.toggle('show', paused);
    }
}

function toggleTrackRecording() {
    isRecording = !isRecording;
    document.getElementById('fTrack').classList.toggle('recording', isRecording);
    document.getElementById('fTrack').textContent = isRecording ? '‚èπÔ∏è Stop Recording' : 'üèÅ Record Track';
    if (isRecording) customTrack = [];
}

function eraseTrack() {
    customTrack = [];
    isRecording = false;
    document.getElementById('fTrack').classList.remove('recording');
    document.getElementById('fTrack').textContent = 'üèÅ Record Track';
    if (trackMesh) { scene.remove(trackMesh); trackMesh = null; }
}

function updateTrack() {
    if (!isRecording) return;
    const last = customTrack[customTrack.length - 1];
    if (!last || Math.hypot(car.x - last.x, car.z - last.z) > 5) {
        customTrack.push({ x: car.x, z: car.z });
        rebuildTrackMesh();
    }
}

function rebuildTrackMesh() {
    if (trackMesh) scene.remove(trackMesh);
    if (customTrack.length < 2) return;
    const hw = 8;
    const verts = [], indices = [];
    for (let i = 0; i < customTrack.length; i++) {
        const p = customTrack[i];
        let dx, dz;
        if (i === 0) { dx = customTrack[1].x - p.x; dz = customTrack[1].z - p.z; }
        else if (i === customTrack.length - 1) { dx = p.x - customTrack[i-1].x; dz = p.z - customTrack[i-1].z; }
        else { dx = customTrack[i+1].x - customTrack[i-1].x; dz = customTrack[i+1].z - customTrack[i-1].z; }
        const len = Math.sqrt(dx*dx + dz*dz) || 1;
        const nx = -dz / len, nz = dx / len;
        verts.push(p.x + nx * hw, 0.03, p.z + nz * hw);
        verts.push(p.x - nx * hw, 0.03, p.z - nz * hw);
        if (i < customTrack.length - 1) {
            const vi = i * 2;
            indices.push(vi, vi+1, vi+2, vi+1, vi+3, vi+2);
        }
    }
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    geo.setIndex(indices);
    geo.computeVertexNormals();
    trackMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: isRecording ? 0xff6644 : 0xffaa00, side: THREE.DoubleSide, transparent: true, opacity: 0.7 }));
    scene.add(trackMesh);
}

function nextCity() {
    if (selLoc === 'custom') {
        selLoc = locKeys[0];
    } else {
        const idx = locKeys.indexOf(selLoc);
        selLoc = locKeys[(idx + 1) % locKeys.length];
    }
    loadRoads();
}

async function searchCity() {
    const query = document.getElementById('citySearch').value.trim();
    if (!query) return;
    const status = document.getElementById('searchStatus');
    status.textContent = 'Searching...';
    status.className = 'search-status';
    try {
        const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
        const data = await res.json();
        if (data.length > 0) {
            const lat = parseFloat(data[0].lat);
            const lon = parseFloat(data[0].lon);
            document.getElementById('customLat').value = lat.toFixed(4);
            document.getElementById('customLon').value = lon.toFixed(4);
            customLoc = { lat, lon, name: data[0].display_name.split(',')[0] };
            status.textContent = '‚úì Found: ' + customLoc.name;
            status.className = 'search-status success';
        } else {
            status.textContent = '‚úó Location not found';
            status.className = 'search-status error';
        }
    } catch (e) {
        status.textContent = '‚úó Search failed';
        status.className = 'search-status error';
    }
}

async function loadRoads() {
    const locName = selLoc === 'custom' ? (customLoc?.name || 'Custom') : LOCS[selLoc].name;
    showLoad('Loading ' + locName + '...');
    roadMeshes.forEach(m => scene.remove(m)); roadMeshes = []; roads = [];
    buildingMeshes.forEach(m => scene.remove(m)); buildingMeshes = [];
    
    if (selLoc === 'custom') {
        const lat = parseFloat(document.getElementById('customLat').value);
        const lon = parseFloat(document.getElementById('customLon').value);
        if (isNaN(lat) || isNaN(lon)) { showLoad('Enter valid coordinates'); return; }
        LOC = { lat, lon };
        customLoc = { lat, lon, name: customLoc?.name || 'Custom' };
    } else {
        LOC = { lat: LOCS[selLoc].lat, lon: LOCS[selLoc].lon };
    }
    
    const radii = [0.02, 0.025, 0.03];
    let loaded = false;
    
    for (const r of radii) {
        if (loaded) break;
        try {
            showLoad('Loading roads...');
            // Load roads and buildings in one query
            const q = `[out:json][timeout:30];(way["highway"~"^(motorway|trunk|primary|secondary|tertiary|residential)$"](${LOC.lat-r},${LOC.lon-r},${LOC.lat+r},${LOC.lon+r});way["building"](${LOC.lat-r},${LOC.lon-r},${LOC.lat+r},${LOC.lon+r}););out body;>;out skel qt;`;
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 25000);
            const res = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: 'data=' + encodeURIComponent(q), signal: controller.signal });
            clearTimeout(timeoutId);
            const data = await res.json();
            const nodes = {};
            data.elements.filter(e => e.type === 'node').forEach(n => nodes[n.id] = n);
            
            // Process roads
            data.elements.filter(e => e.type === 'way' && e.tags?.highway).forEach(way => {
                const pts = way.nodes.map(id => nodes[id]).filter(n => n).map(n => geoToWorld(n.lat, n.lon));
                if (pts.length < 2) return;
                const type = way.tags?.highway || 'residential';
                const width = type.includes('motorway') ? 16 : type.includes('trunk') ? 14 : type.includes('primary') ? 12 : type.includes('secondary') ? 10 : 8;
                const limit = type.includes('motorway') ? 65 : type.includes('trunk') ? 55 : type.includes('primary') ? 40 : type.includes('secondary') ? 35 : 25;
                const name = way.tags?.name || type.charAt(0).toUpperCase() + type.slice(1);
                roads.push({ pts, width, limit, name, type });
                const hw = width / 2;
                const verts = [], indices = [];
                for (let i = 0; i < pts.length; i++) {
                    const p = pts[i];
                    let dx, dz;
                    if (i === 0) { dx = pts[1].x - p.x; dz = pts[1].z - p.z; }
                    else if (i === pts.length - 1) { dx = p.x - pts[i-1].x; dz = p.z - pts[i-1].z; }
                    else { dx = pts[i+1].x - pts[i-1].x; dz = pts[i+1].z - pts[i-1].z; }
                    const len = Math.sqrt(dx*dx + dz*dz) || 1;
                    const nx = -dz / len, nz = dx / len;
                    verts.push(p.x + nx * hw, 0.02, p.z + nz * hw);
                    verts.push(p.x - nx * hw, 0.02, p.z - nz * hw);
                    if (i < pts.length - 1) { const vi = i * 2; indices.push(vi, vi+1, vi+2, vi+1, vi+3, vi+2); }
                }
                const geo = new THREE.BufferGeometry();
                geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
                geo.setIndex(indices);
                geo.computeVertexNormals();
                const mesh = new THREE.Mesh(geo, new THREE.MeshLambertMaterial({ color: 0x333333, side: THREE.DoubleSide }));
                scene.add(mesh); roadMeshes.push(mesh);
            });
            
            // Process buildings - OPTIMIZED
            showLoad('Loading buildings...');
            const buildingMats = [
                new THREE.MeshLambertMaterial({ color: 0x8899aa }),
                new THREE.MeshLambertMaterial({ color: 0x998877 }),
                new THREE.MeshLambertMaterial({ color: 0x7788aa }),
                new THREE.MeshLambertMaterial({ color: 0x887799 })
            ];
            let buildingCount = 0;
            const maxBuildings = 300;
            
            // Build spatial hash for roads (for fast lookup during gameplay)
            roadGrid = {};
            roads.forEach((road, ri) => {
                for (let i = 0; i < road.pts.length; i++) {
                    const p = road.pts[i];
                    const gx = Math.floor(p.x / roadGridSize);
                    const gz = Math.floor(p.z / roadGridSize);
                    const key = gx + ',' + gz;
                    if (!roadGrid[key]) roadGrid[key] = [];
                    roadGrid[key].push({ road, idx: i });
                }
            });
            
            // Build road cells set for building filtering
            const roadCells = new Set();
            const cellSize = 25;
            roads.forEach(road => {
                road.pts.forEach(p => {
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            roadCells.add(Math.floor(p.x/cellSize + dx) + ',' + Math.floor(p.z/cellSize + dz));
                        }
                    }
                });
            });
            
            const buildingWays = data.elements.filter(e => e.type === 'way' && e.tags?.building);
            for (const way of buildingWays) {
                if (buildingCount >= maxBuildings) break;
                
                const pts = way.nodes.map(id => nodes[id]).filter(n => n).map(n => geoToWorld(n.lat, n.lon));
                if (pts.length < 3) continue;
                
                // Bounding box
                let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
                pts.forEach(p => {
                    minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x);
                    minZ = Math.min(minZ, p.z); maxZ = Math.max(maxZ, p.z);
                });
                
                const w = maxX - minX, d = maxZ - minZ;
                if (w < 4 || d < 4) continue; // Skip small
                
                // Skip if on road
                const cx = Math.floor((minX + maxX) / 2 / cellSize);
                const cz = Math.floor((minZ + maxZ) / 2 / cellSize);
                if (roadCells.has(cx + ',' + cz)) continue;
                
                // Height estimate
                let height = 8 + Math.random() * 10;
                if (way.tags['building:levels']) height = parseFloat(way.tags['building:levels']) * 3;
                
                // Use simple box instead of extrusion
                const geo = new THREE.BoxGeometry(w, height, d);
                const mesh = new THREE.Mesh(geo, buildingMats[buildingCount % buildingMats.length]);
                mesh.position.set((minX + maxX) / 2, height / 2, (minZ + maxZ) / 2);
                scene.add(mesh);
                buildingMeshes.push(mesh);
                buildingCount++;
            }
            
            if (roads.length > 0) { loaded = true; spawnOnRoad(); hideLoad(); if (gameStarted) startMode(); console.log('Loaded', roads.length, 'roads,', buildingMeshes.length, 'buildings'); }
            else showLoad('No roads found, trying larger area...');
        } catch (e) { console.error(e); showLoad('Retrying...'); }
    }
    if (!loaded) { showLoad('Failed to load. Click to retry.'); document.getElementById('loading').onclick = () => { document.getElementById('loading').onclick = null; loadRoads(); }; }
}

function spawnOnRoad() {
    // Find a main road (primary/secondary) closest to center (0,0)
    let bestRoad = null;
    let bestDist = Infinity;
    let bestPtIdx = 0;
    
    roads.forEach(road => {
        const isMain = road.type.includes('primary') || road.type.includes('secondary') || road.type.includes('trunk');
        const priority = isMain ? 0 : 100; // Prefer main roads
        
        for (let i = 0; i < road.pts.length; i++) {
            const p = road.pts[i];
            const dist = Math.hypot(p.x, p.z) + priority;
            if (dist < bestDist) {
                bestDist = dist;
                bestRoad = road;
                bestPtIdx = i;
            }
        }
    });
    
    if (!bestRoad) {
        bestRoad = roads[0];
        bestPtIdx = Math.floor(bestRoad.pts.length / 2);
    }
    
    car.x = bestRoad.pts[bestPtIdx].x;
    car.z = bestRoad.pts[bestPtIdx].z;
    
    // Face along the road
    if (bestPtIdx < bestRoad.pts.length - 1) {
        car.angle = Math.atan2(
            bestRoad.pts[bestPtIdx + 1].x - bestRoad.pts[bestPtIdx].x,
            bestRoad.pts[bestPtIdx + 1].z - bestRoad.pts[bestPtIdx].z
        );
    } else if (bestPtIdx > 0) {
        car.angle = Math.atan2(
            bestRoad.pts[bestPtIdx].x - bestRoad.pts[bestPtIdx - 1].x,
            bestRoad.pts[bestPtIdx].z - bestRoad.pts[bestPtIdx - 1].z
        );
    }
    
    car.speed = 0; car.vx = 0; car.vz = 0;
    carMesh.position.set(car.x, 0, car.z);
    carMesh.rotation.y = car.angle;
}

function findNearestRoad(x, z) {
    let best = { road: null, dist: Infinity, pt: null };
    
    // Check nearby grid cells only
    const gx = Math.floor(x / roadGridSize);
    const gz = Math.floor(z / roadGridSize);
    const checked = new Set();
    
    for (let dx = -2; dx <= 2; dx++) {
        for (let dz = -2; dz <= 2; dz++) {
            const key = (gx + dx) + ',' + (gz + dz);
            const cell = roadGrid[key];
            if (!cell) continue;
            
            for (const { road, idx } of cell) {
                const segKey = road.name + idx;
                if (checked.has(segKey)) continue;
                checked.add(segKey);
                
                if (idx >= road.pts.length - 1) continue;
                const p1 = road.pts[idx], p2 = road.pts[idx + 1];
                const rdx = p2.x - p1.x, rdz = p2.z - p1.z, len2 = rdx*rdx + rdz*rdz;
                if (len2 === 0) continue;
                let t = ((x - p1.x)*rdx + (z - p1.z)*rdz) / len2;
                t = Math.max(0, Math.min(1, t));
                const nx = p1.x + t*rdx, nz = p1.z + t*rdz;
                const d = Math.hypot(x - nx, z - nz);
                if (d < best.dist) best = { road, dist: d, pt: { x: nx, z: nz } };
            }
        }
    }
    
    // Fallback to full search if nothing found nearby
    if (!best.road) {
        roads.forEach(road => {
            for (let i = 0; i < road.pts.length - 1; i++) {
                const p1 = road.pts[i], p2 = road.pts[i+1];
                const dx = p2.x - p1.x, dz = p2.z - p1.z, len2 = dx*dx + dz*dz;
                if (len2 === 0) continue;
                let t = ((x - p1.x)*dx + (z - p1.z)*dz) / len2;
                t = Math.max(0, Math.min(1, t));
                const nx = p1.x + t*dx, nz = p1.z + t*dz;
                const d = Math.hypot(x - nx, z - nz);
                if (d < best.dist) best = { road, dist: d, pt: { x: nx, z: nz } };
            }
        });
    }
    return best;
}

function update(dt) {
    if (paused || !gameStarted) return;
    const left = keys.KeyA || keys.ArrowLeft, right = keys.KeyD || keys.ArrowRight;
    const gas = keys.KeyW || keys.ArrowUp, reverse = keys.KeyS || keys.ArrowDown;
    const braking = keys.Space, offMode = keys.ShiftLeft || keys.ShiftRight;
    const boostKey = keys.ControlLeft || keys.ControlRight;
    
    if (boostKey && car.boostReady && !car.boost) { car.boost = true; car.boostTime = CFG.boostDur; car.boostReady = false; }
    if (car.boost) { car.boostTime -= dt; if (car.boostTime <= 0) { car.boost = false; car.boostTime = 0; } }
    if (!boostKey && !car.boost) car.boostReady = true;
    
    const nr = findNearestRoad(car.x, car.z);
    const edge = nr.road ? nr.road.width / 2 + 10 : 20;
    car.onRoad = nr.dist < edge;
    car.road = nr.road;
    
    const baseMax = car.onRoad ? CFG.maxSpd : CFG.offMax;
    const maxSpd = car.boost ? CFG.boostMax : baseMax;
    const friction = car.onRoad ? CFG.friction : CFG.offFriction;
    const accel = car.boost ? CFG.boostAccel : CFG.accel;
    
    const spd = Math.abs(car.speed);
    
    // Acceleration
    if (gas && !braking) {
        car.speed += accel * (1 - (spd / maxSpd) * 0.7) * dt;
    }
    
    // Braking (Space) - slows down, enables drift
    if (braking && spd > 5) {
        car.speed *= (1 - CFG.brakeForce * dt);
    }
    
    // Reverse (S) - only when slow or stopped
    if (reverse && !braking) {
        if (car.speed > 10) {
            // If moving forward fast, brake first
            car.speed -= CFG.brake * dt;
        } else {
            // Reverse
            car.speed -= accel * 0.5 * dt;
        }
    }
    
    // Natural friction when coasting
    if (!gas && !reverse && !braking) {
        car.speed *= (1 - friction * dt * 0.01);
    }
    
    // Clamp speed
    car.speed = Math.max(-maxSpd * 0.3, Math.min(maxSpd, car.speed));
    
    // Steering - speed sensitive
    let tr = CFG.turnLow;
    if (spd > CFG.turnMin) { 
        const t = Math.min(1, (spd - CFG.turnMin) / (CFG.maxSpd - CFG.turnMin)); 
        tr = CFG.turnHigh + (CFG.turnLow - CFG.turnHigh) * (1 - t); 
    }
    
    // Reverse steering direction when going backwards
    const steerDir = car.speed >= 0 ? 1 : -1;
    if (left) car.angle += tr * dt * steerDir;
    if (right) car.angle -= tr * dt * steerDir;
    
    // Grip calculation
    let grip = car.onRoad ? CFG.gripRoad : CFG.gripOff;
    
    // Braking while turning = drift!
    if (braking && (left || right) && spd > 20) {
        grip = CFG.gripDrift;
    }
    // Just braking hard also reduces grip
    else if (braking && spd > 40) {
        grip = CFG.gripBrake;
    }
    
    // Hard cornering at high speed = natural drift
    if ((left || right) && spd > 80) {
        const cornerFactor = Math.min(0.35, (spd - 80) / 200);
        grip -= cornerFactor;
    }
    
    grip = Math.max(0.25, grip);
    
    // Apply velocity based on grip
    const fx = Math.sin(car.angle) * car.speed;
    const fz = Math.cos(car.angle) * car.speed;
    
    // Lower grip = velocity maintains momentum (drift)
    const rc = CFG.driftRec * grip * dt;
    car.vx += (fx - car.vx) * Math.min(1, rc);
    car.vz += (fz - car.vz) * Math.min(1, rc);
    
    // Calculate drift angle
    const velMag = Math.hypot(car.vx, car.vz);
    if (velMag > 5) {
        const velAngle = Math.atan2(car.vx, car.vz);
        let da = car.angle - velAngle;
        while (da > Math.PI) da -= Math.PI * 2;
        while (da < -Math.PI) da += Math.PI * 2;
        car.driftAngle = da;
    } else car.driftAngle = 0;
    
    let nx = car.x + car.vx * dt, nz = car.z + car.vz * dt;
    
    if (!offMode && roads.length > 0) {
        const chk = findNearestRoad(nx, nz);
        const hw = chk.road ? chk.road.width / 2 : 8, soft = hw + 2, hard = hw + 6;
        if (chk.dist > soft && chk.pt) {
            const over = Math.min(1, (chk.dist - soft) / (hard - soft));
            const px = chk.pt.x - nx, pz = chk.pt.z - nz, pd = Math.hypot(px, pz);
            if (pd > 0) { nx += (px/pd) * over * 0.6 * (chk.dist - soft); nz += (pz/pd) * over * 0.6 * (chk.dist - soft); }
            if (chk.dist > hard) {
                car.speed *= 0.85; car.vx *= 0.85; car.vz *= 0.85;
                const pa = Math.atan2(nz - chk.pt.z, nx - chk.pt.x);
                nx = chk.pt.x + Math.cos(pa) * (hw + 1); nz = chk.pt.z + Math.sin(pa) * (hw + 1);
            }
        }
    }
    car.x = nx; car.z = nz;
    carMesh.position.set(car.x, 0, car.z);
    carMesh.rotation.y = car.angle;
    
    // Rotate wheels
    const wheelRot = car.speed * dt * 0.5;
    wheelMeshes.forEach(w => w.rotation.x += wheelRot);
    
    updateTrack();
    updatePolice(dt);
    updateMode(dt);
}

function updatePolice(dt) {
    if (!policeOn || police.length === 0) return;
    const mph = Math.abs(car.speed * 0.5);
    const limit = car.road?.limit || 25;
    const speeding = mph > limit;
    police.forEach(cop => {
        cop.siren += dt * 10;
        if (cop.cooldown > 0) cop.cooldown -= dt;
        const dx = car.x - cop.x, dz = car.z - cop.z, dist = Math.hypot(dx, dz);
        if (speeding && dist < CFG.policeDist) cop.chasing = true;
        if (!speeding && dist < 100) cop.chasing = false;
        if (cop.chasing) {
            const ta = Math.atan2(dx, dz);
            let ad = ta - cop.angle;
            while (ad > Math.PI) ad -= Math.PI * 2;
            while (ad < -Math.PI) ad += Math.PI * 2;
            cop.angle += ad * 4 * dt;
            if (dist > 50) cop.speed += CFG.policeAccel * dt;
            else cop.speed *= 0.95;
            cop.speed = Math.min(cop.speed, CFG.policeSpd);
            cop.mesh.children[2].material.color.setHex(Math.sin(cop.siren) > 0 ? 0xff0000 : 0x440000);
            cop.mesh.children[3].material.color.setHex(Math.sin(cop.siren) > 0 ? 0x000044 : 0x0066ff);
        } else cop.speed *= 0.98;
        let cnx = cop.x + Math.sin(cop.angle) * cop.speed * dt;
        let cnz = cop.z + Math.cos(cop.angle) * cop.speed * dt;
        const nr = findNearestRoad(cnx, cnz);
        if (nr.dist < 50 || cop.chasing) { cop.x = cnx; cop.z = cnz; }
        else if (nr.pt) { cop.x = nr.pt.x; cop.z = nr.pt.z; }
        cop.mesh.position.set(cop.x, 0, cop.z);
        cop.mesh.rotation.y = cop.angle;
        if (dist < 4 && cop.chasing && cop.cooldown <= 0) {
            policeHits++;
            cop.cooldown = 2;
            car.speed *= 0.3;
            cop.speed = 0;
            document.getElementById('police').textContent = 'üíî ' + policeHits + '/3';
            if (policeHits >= 3) { paused = true; document.getElementById('caughtScreen').classList.add('show'); }
        }
    });
}

function spawnPolice() {
    policeMeshes.forEach(m => scene.remove(m)); policeMeshes = []; police = []; policeHits = 0;
    document.getElementById('police').textContent = 'üíî 0/3';
    for (let i = 0; i < 2; i++) {
        const mesh = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.5, 3.5), new THREE.MeshLambertMaterial({ color: 0x111111 }));
        body.position.y = 0.5; mesh.add(body);
        const hood = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.1, 1.2), new THREE.MeshLambertMaterial({ color: 0xffffff }));
        hood.position.set(0, 0.8, 0.7); mesh.add(hood);
        const sr = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.12, 0.2), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        sr.position.set(-0.3, 0.92, 0); mesh.add(sr);
        const sb = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.12, 0.2), new THREE.MeshBasicMaterial({ color: 0x0066ff }));
        sb.position.set(0.3, 0.92, 0); mesh.add(sb);
        const ang = car.angle + Math.PI + (i === 0 ? 0.4 : -0.4);
        const dist = 50 + i * 20;
        mesh.position.set(car.x + Math.sin(ang) * dist, 0, car.z + Math.cos(ang) * dist);
        scene.add(mesh); policeMeshes.push(mesh);
        police.push({ mesh, x: mesh.position.x, z: mesh.position.z, angle: car.angle, speed: 0, siren: i * Math.PI, chasing: false, cooldown: 0 });
    }
}

function clearPolice() { policeMeshes.forEach(m => scene.remove(m)); policeMeshes = []; police = []; }

function pickRoadPt() { if (roads.length === 0) return null; const rd = roads[Math.floor(Math.random() * roads.length)]; return rd.pts[Math.floor(Math.random() * rd.pts.length)]; }

function clearObjectives() {
    cpMeshes.forEach(m => scene.remove(m)); cpMeshes = []; checkpoints = []; cpCollected = 0;
    if (destMesh) { scene.remove(destMesh); destMesh = null; }
    destination = null; trialDone = false;
}

function spawnDest() {
    clearObjectives();
    let best = null;
    for (let i = 0; i < 40; i++) {
        const p = pickRoadPt(); if (!p) continue;
        const d = Math.hypot(p.x - car.x, p.z - car.z);
        if (d > 400 && d < 1200) { best = p; break; }
        if (!best || d > Math.hypot(best.x - car.x, best.z - car.z)) best = p;
    }
    if (!best) return;
    destination = { x: best.x, z: best.z };
    const grp = new THREE.Group();
    const ring = new THREE.Mesh(new THREE.TorusGeometry(12, 1, 8, 24), new THREE.MeshBasicMaterial({ color: 0xffcc00 }));
    ring.rotation.x = Math.PI / 2; ring.position.y = 0.5; grp.add(ring);
    const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 40, 8), new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.3 }));
    beam.position.y = 20; grp.add(beam);
    grp.position.set(best.x, 0, best.z);
    scene.add(grp); destMesh = grp;
}

function spawnCheckpoints() {
    clearObjectives();
    for (let i = 0; i < 8; i++) {
        let p = null;
        for (let t = 0; t < 60; t++) {
            const c = pickRoadPt(); if (!c) continue;
            if (Math.hypot(c.x - car.x, c.z - car.z) < 250) continue;
            if (checkpoints.every(cp => Math.hypot(c.x - cp.x, c.z - cp.z) > 200)) { p = c; break; }
        }
        if (!p) p = pickRoadPt();
        if (!p) continue;
        checkpoints.push({ x: p.x, z: p.z, collected: false, idx: i + 1 });
        const grp = new THREE.Group();
        const ring = new THREE.Mesh(new THREE.TorusGeometry(10, 0.8, 8, 20), new THREE.MeshBasicMaterial({ color: 0xff3366 }));
        ring.rotation.x = Math.PI / 2; ring.position.y = 0.5; grp.add(ring);
        grp.position.set(p.x, 0, p.z);
        scene.add(grp); cpMeshes.push(grp);
    }
}

function startMode() { gameTimer = 0; clearObjectives(); if (gameMode === 'trial') spawnDest(); else if (gameMode === 'checkpoint') spawnCheckpoints(); }

function updateMode(dt) {
    if (gameMode === 'trial' || gameMode === 'checkpoint') gameTimer += dt;
    cpMeshes.forEach(m => m.rotation.y += dt * 1.5);
    if (destMesh) destMesh.rotation.y += dt * 1.2;
    if (gameMode === 'trial' && destination && !trialDone) {
        const d = Math.hypot(destination.x - car.x, destination.z - car.z);
        if (d < CFG.cpRadius) { trialDone = true; showResult('Destination Reached!', 'Time: ' + fmtTime(gameTimer)); }
        else if (gameTimer > CFG.trialTime) showResult("Time's Up!", 'Result: Failed');
    }
    if (gameMode === 'checkpoint') {
        for (let i = 0; i < checkpoints.length; i++) {
            const cp = checkpoints[i]; if (cp.collected) continue;
            if (Math.hypot(cp.x - car.x, cp.z - car.z) < CFG.cpRadius) {
                cp.collected = true; cpCollected++;
                if (cpMeshes[i]) cpMeshes[i].visible = false;
                if (cpCollected >= checkpoints.length) showResult('All Checkpoints!', 'Time: ' + fmtTime(gameTimer));
                break;
            }
        }
    }
}

function fmtTime(s) { s = Math.max(0, Math.floor(s)); return String(Math.floor(s/60)).padStart(2,'0') + ':' + String(s%60).padStart(2,'0'); }
function showResult(title, stats) { document.getElementById('resultTitle').textContent = title; document.getElementById('resultStats').innerHTML = stats; document.getElementById('resultScreen').classList.add('show'); paused = true; }
function hideResult() { document.getElementById('resultScreen').classList.remove('show'); }

function updateCamera() {
    const lb = keys.KeyV;
    const d = 10, h = 5;
    if (camMode === 0) {
        const ox = -Math.sin(car.angle) * (lb ? -d : d);
        const oz = -Math.cos(car.angle) * (lb ? -d : d);
        camera.position.set(car.x + ox, h, car.z + oz);
        camera.lookAt(car.x, 0.5, car.z);
    } else if (camMode === 1) {
        camera.position.set(car.x, 1.5, car.z);
        const dir = lb ? -1 : 1;
        camera.lookAt(car.x + Math.sin(car.angle) * 10 * dir, 1, car.z + Math.cos(car.angle) * 10 * dir);
    } else {
        camera.position.set(car.x, 50, car.z + 15);
        camera.lookAt(car.x, 0, car.z);
    }
}

function updateHUD() {
    const mph = Math.abs(Math.round(car.speed * 0.5));
    const limit = car.road?.limit || 25;
    const locName = selLoc === 'custom' ? (customLoc?.name || 'Custom') : LOCS[selLoc].name;
    document.getElementById('speed').textContent = mph;
    document.getElementById('speed').classList.toggle('fast', mph > limit || car.boost);
    document.getElementById('limit').textContent = limit;
    document.getElementById('street').textContent = (car.road?.name || 'Off Road') + ' ‚Ä¢ ' + locName;
    const bf = document.getElementById('boostFill');
    bf.style.width = car.boost ? (car.boostTime / CFG.boostDur * 100) + '%' : (car.boostReady ? '100%' : '0%');
    bf.classList.toggle('active', car.boost);
    document.getElementById('indBrake').classList.toggle('on', keys.Space);
    document.getElementById('indBoost').classList.toggle('on', car.boost);
    const isDrifting = Math.abs(car.driftAngle) > 0.15 && Math.abs(car.speed) > 30;
    document.getElementById('indDrift').classList.toggle('on', isDrifting);
    if (isDrifting) document.getElementById('indDrift').textContent = 'DRIFT ' + Math.round(Math.abs(car.driftAngle) * 180 / Math.PI) + '¬∞';
    else document.getElementById('indDrift').textContent = 'DRIFT';
    document.getElementById('indOff').classList.toggle('on', keys.ShiftLeft || keys.ShiftRight);
    document.getElementById('indOff').classList.toggle('warn', !car.onRoad && !(keys.ShiftLeft || keys.ShiftRight));
    document.getElementById('offRoadWarn').classList.toggle('active', !car.onRoad && !(keys.ShiftLeft || keys.ShiftRight));
    const geo = { lat: LOC.lat - (car.z / SCALE), lon: LOC.lon + (car.x / (SCALE * Math.cos(LOC.lat * Math.PI / 180))) };
    let hdg = (-car.angle * 180 / Math.PI + 90) % 360; if (hdg < 0) hdg += 360;
    const dirs = ['N','NE','E','SE','S','SW','W','NW'];
    document.getElementById('coords').textContent = geo.lat.toFixed(4) + ', ' + geo.lon.toFixed(4) + ' | ' + dirs[Math.round(hdg/45)%8] + ' ' + Math.round(hdg) + '¬∞';
    if (gameMode === 'free') { document.getElementById('modeTitle').textContent = 'Free Roam'; document.getElementById('modeTimer').textContent = '--:--'; document.getElementById('modeInfo').textContent = ''; }
    else if (gameMode === 'trial') { document.getElementById('modeTitle').textContent = 'Time Trial'; document.getElementById('modeTimer').textContent = fmtTime(Math.max(0, CFG.trialTime - gameTimer)); document.getElementById('modeInfo').textContent = destination ? Math.round(Math.hypot(destination.x - car.x, destination.z - car.z)) + 'm' : ''; }
    else { document.getElementById('modeTitle').textContent = 'Checkpoint'; document.getElementById('modeTimer').textContent = fmtTime(gameTimer); document.getElementById('modeInfo').textContent = cpCollected + '/' + checkpoints.length; }
}

function drawMinimap() {
    const w = 150, h = 150;
    mctx.fillStyle = '#111';
    mctx.fillRect(0, 0, w, h);
    const ms = 0.07, mx = 75, my = 75;
    mctx.lineWidth = 2;
    roads.forEach(r => {
        let vis = false;
        for (const p of r.pts) { if (Math.abs(p.x - car.x) < 1200 && Math.abs(p.z - car.z) < 1200) { vis = true; break; } }
        if (!vis) return;
        mctx.strokeStyle = r === car.road ? '#0fc' : '#0a8';
        mctx.beginPath();
        r.pts.forEach((p, i) => { const sx = mx + (p.x - car.x) * ms, sy = my + (p.z - car.z) * ms; i === 0 ? mctx.moveTo(sx, sy) : mctx.lineTo(sx, sy); });
        mctx.stroke();
    });
    if (gameMode === 'checkpoint') {
        checkpoints.forEach(cp => {
            if (cp.collected) return;
            const sx = mx + (cp.x - car.x) * ms, sy = my + (cp.z - car.z) * ms;
            if (Math.abs(sx - mx) < 70 && Math.abs(sy - my) < 70) { mctx.fillStyle = '#f36'; mctx.beginPath(); mctx.arc(sx, sy, 4, 0, Math.PI * 2); mctx.fill(); }
        });
    }
    if (gameMode === 'trial' && destination) {
        let sx = mx + (destination.x - car.x) * ms, sy = my + (destination.z - car.z) * ms;
        sx = Math.max(8, Math.min(w - 8, sx)); sy = Math.max(8, Math.min(h - 8, sy));
        mctx.fillStyle = trialDone ? '#0f8' : '#fc0'; mctx.beginPath(); mctx.arc(sx, sy, 5, 0, Math.PI * 2); mctx.fill();
    }
    if (policeOn) {
        police.forEach(cop => {
            const sx = mx + (cop.x - car.x) * ms, sy = my + (cop.z - car.z) * ms;
            if (Math.abs(sx - mx) < 70 && Math.abs(sy - my) < 70) { mctx.fillStyle = cop.chasing ? '#f00' : '#06f'; mctx.beginPath(); mctx.arc(sx, sy, 3, 0, Math.PI * 2); mctx.fill(); }
        });
    }
    if (customTrack.length >= 2) {
        mctx.strokeStyle = isRecording ? '#f64' : '#fa0';
        mctx.lineWidth = 3;
        mctx.beginPath();
        customTrack.forEach((p, i) => { const sx = mx + (p.x - car.x) * ms, sy = my + (p.z - car.z) * ms; i === 0 ? mctx.moveTo(sx, sy) : mctx.lineTo(sx, sy); });
        mctx.stroke();
    }
    mctx.save(); mctx.translate(mx, my); mctx.rotate(-car.angle);
    mctx.fillStyle = '#f36'; mctx.beginPath(); mctx.moveTo(0, 6); mctx.lineTo(-4, -5); mctx.lineTo(4, -5); mctx.fill();
    mctx.restore();
}

let lastTime = 0;
function renderLoop(t = 0) {
    requestAnimationFrame(renderLoop);
    const dt = Math.min((t - lastTime) / 1000, 0.1);
    lastTime = t;
    if (gameStarted) { update(dt); updateCamera(); updateHUD(); drawMinimap(); }
    renderer.render(scene, camera);
}

function showLoad(txt) { document.getElementById('loadText').textContent = txt; document.getElementById('loading').classList.add('show'); }
function hideLoad() { document.getElementById('loading').classList.remove('show'); }

function setupUI() {
    // Tabs
    document.querySelectorAll('.tab-btn').forEach(btn => btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
    }));
    // Locations
    document.querySelectorAll('.loc').forEach(el => el.addEventListener('click', () => {
        document.querySelectorAll('.loc').forEach(e => e.classList.remove('sel'));
        el.classList.add('sel');
        selLoc = el.dataset.loc;
        document.getElementById('customPanel').classList.toggle('show', selLoc === 'custom');
    }));
    // Custom location search
    document.getElementById('searchBtn').addEventListener('click', searchCity);
    document.getElementById('citySearch').addEventListener('keypress', e => { if (e.key === 'Enter') searchCity(); });
    // Game modes
    document.querySelectorAll('.mode').forEach(el => el.addEventListener('click', () => {
        document.querySelectorAll('.mode').forEach(e => e.classList.remove('sel'));
        el.classList.add('sel');
        gameMode = el.dataset.mode;
    }));
    // Start
    document.getElementById('startBtn').addEventListener('click', async () => {
        document.getElementById('titleScreen').classList.add('hidden');
        document.getElementById('hud').classList.add('show');
        document.getElementById('minimap').classList.add('show');
        document.getElementById('modeHud').classList.add('show');
        document.getElementById('floatMenu').classList.add('show');
        document.getElementById('controlsTab').classList.add('show');
        document.getElementById('coords').classList.add('show');
        gameStarted = true;
        await loadRoads();
    });
    // Float menu
    document.getElementById('floatBtn').addEventListener('click', () => document.getElementById('floatMenu').classList.toggle('open'));
    document.getElementById('fHome').addEventListener('click', () => {
        gameStarted = false; paused = false; clearObjectives(); clearPolice(); policeOn = false; eraseTrack();
        document.getElementById('floatMenu').classList.remove('open');
        document.getElementById('titleScreen').classList.remove('hidden');
        ['hud','minimap','modeHud','police','floatMenu','pauseScreen','resultScreen','caughtScreen','controlsTab','coords'].forEach(id => document.getElementById(id).classList.remove('show'));
    });
    document.getElementById('fNextCity').addEventListener('click', () => { nextCity(); document.getElementById('floatMenu').classList.remove('open'); });
    document.getElementById('fPolice').addEventListener('click', () => {
        policeOn = !policeOn;
        document.getElementById('fPolice').classList.toggle('on', policeOn);
        document.getElementById('police').classList.toggle('show', policeOn);
        if (policeOn) spawnPolice(); else clearPolice();
        document.getElementById('floatMenu').classList.remove('open');
    });
    document.getElementById('fRespawn').addEventListener('click', () => { spawnOnRoad(); document.getElementById('floatMenu').classList.remove('open'); });
    document.getElementById('fRespawnRand').addEventListener('click', () => {
        if (roads.length > 0) {
            const rd = roads[Math.floor(Math.random() * roads.length)];
            const idx = Math.floor(Math.random() * rd.pts.length);
            car.x = rd.pts[idx].x; car.z = rd.pts[idx].z;
            if (idx < rd.pts.length - 1) car.angle = Math.atan2(rd.pts[idx+1].x - rd.pts[idx].x, rd.pts[idx+1].z - rd.pts[idx].z);
            car.speed = 0; car.vx = 0; car.vz = 0;
            carMesh.position.set(car.x, 0, car.z); carMesh.rotation.y = car.angle;
        }
        document.getElementById('floatMenu').classList.remove('open');
    });
    document.getElementById('fTrack').addEventListener('click', () => { toggleTrackRecording(); document.getElementById('floatMenu').classList.remove('open'); });
    document.getElementById('fEraseTrack').addEventListener('click', () => { eraseTrack(); document.getElementById('floatMenu').classList.remove('open'); });
    document.getElementById('ctrlHeader').addEventListener('click', () => document.getElementById('ctrlContent').classList.toggle('hidden'));
    document.getElementById('resumeBtn').addEventListener('click', () => { paused = false; document.getElementById('pauseScreen').classList.remove('show'); });
    document.getElementById('restartBtn').addEventListener('click', () => { paused = false; document.getElementById('pauseScreen').classList.remove('show'); startMode(); });
    document.getElementById('menuBtn').addEventListener('click', () => document.getElementById('fHome').click());
    document.getElementById('caughtBtn').addEventListener('click', () => { document.getElementById('caughtScreen').classList.remove('show'); policeHits = 0; paused = false; document.getElementById('police').textContent = 'üíî 0/3'; spawnOnRoad(); });
    document.getElementById('againBtn').addEventListener('click', () => { hideResult(); paused = false; startMode(); });
    document.getElementById('freeBtn').addEventListener('click', () => { hideResult(); paused = false; gameMode = 'free'; clearObjectives(); });
    document.getElementById('resMenuBtn').addEventListener('click', () => { hideResult(); document.getElementById('fHome').click(); });
}

init();
</script>
</body></html>
