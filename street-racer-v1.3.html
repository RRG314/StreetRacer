<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Street Racer - Baltimore & Hollywood</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a0f; overflow: hidden; font-family: 'Rajdhani', sans-serif; }
        
        /* ===== TITLE SCREEN ===== */
        #titleScreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2f 50%, #0a0a0f 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 2000; }
        #titleScreen.hidden { display: none; }
        .title-logo { font-family: 'Orbitron', monospace; font-size: 64px; font-weight: 900; color: #00ffc8; text-shadow: 0 0 20px #00ffc8, 0 0 40px #00ffc8, 0 0 80px rgba(0,255,200,0.5); letter-spacing: 8px; margin-bottom: 10px; animation: titlePulse 2s ease-in-out infinite; }
        .title-subtitle { font-family: 'Rajdhani', sans-serif; font-size: 24px; color: rgba(255,255,255,0.6); letter-spacing: 12px; text-transform: uppercase; margin-bottom: 60px; }
        @keyframes titlePulse { 0%, 100% { text-shadow: 0 0 20px #00ffc8, 0 0 40px #00ffc8; } 50% { text-shadow: 0 0 30px #00ffc8, 0 0 60px #00ffc8, 0 0 100px rgba(0,255,200,0.8); } }
        
        .menu-section { margin-bottom: 40px; text-align: center; }
        .menu-label { font-family: 'Orbitron', monospace; font-size: 12px; color: rgba(255,255,255,0.4); letter-spacing: 3px; margin-bottom: 15px; text-transform: uppercase; }
        
        .location-select { display: flex; gap: 20px; margin-bottom: 40px; }
        .location-btn { background: rgba(0,0,0,0.5); border: 2px solid rgba(0,255,200,0.3); border-radius: 12px; padding: 20px 30px; cursor: pointer; transition: all 0.3s; min-width: 180px; }
        .location-btn:hover { border-color: #00ffc8; background: rgba(0,255,200,0.1); transform: translateY(-3px); }
        .location-btn.selected { border-color: #00ffc8; background: rgba(0,255,200,0.2); box-shadow: 0 0 30px rgba(0,255,200,0.3); }
        .location-btn .city { font-family: 'Orbitron', monospace; font-size: 18px; color: #00ffc8; margin-bottom: 5px; }
        .location-btn .state { font-size: 14px; color: rgba(255,255,255,0.5); }
        
        .mode-select { display: flex; gap: 15px; margin-bottom: 50px; }
        .mode-btn { background: rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.2); border-radius: 10px; padding: 15px 25px; cursor: pointer; transition: all 0.3s; }
        .mode-btn:hover { border-color: rgba(255,255,255,0.5); background: rgba(255,255,255,0.05); }
        .mode-btn.selected { border-color: #ff3366; background: rgba(255,51,102,0.2); box-shadow: 0 0 20px rgba(255,51,102,0.3); }
        .mode-btn .mode-icon { font-size: 24px; margin-bottom: 5px; }
        .mode-btn .mode-name { font-family: 'Orbitron', monospace; font-size: 14px; color: #fff; }
        .mode-btn .mode-desc { font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 5px; }
        
        .start-btn { background: linear-gradient(135deg, #00ffc8 0%, #00aa88 100%); border: none; border-radius: 12px; padding: 20px 60px; font-family: 'Orbitron', monospace; font-size: 20px; font-weight: 700; color: #000; cursor: pointer; transition: all 0.3s; text-transform: uppercase; letter-spacing: 4px; }
        .start-btn:hover { transform: scale(1.05); box-shadow: 0 0 40px rgba(0,255,200,0.5); }
        
        .title-footer { position: absolute; bottom: 30px; text-align: center; }
        .title-footer a { color: rgba(255,255,255,0.3); font-size: 12px; text-decoration: none; }
        .title-footer a:hover { color: rgba(255,255,255,0.6); }
        .version { color: rgba(255,255,255,0.2); font-size: 11px; margin-top: 10px; }
        
        /* ===== HOW TO PLAY OVERLAY ===== */
        #howToPlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 3000; }
        #howToPlay.visible { display: flex; }
        .help-panel { background: linear-gradient(135deg, rgba(20,20,30,0.98) 0%, rgba(10,10,20,0.98) 100%); border: 1px solid rgba(0,255,200,0.3); border-radius: 16px; padding: 40px 50px; max-width: 600px; max-height: 80vh; overflow-y: auto; }
        .help-title { font-family: 'Orbitron', monospace; font-size: 28px; color: #00ffc8; text-align: center; margin-bottom: 30px; }
        .help-section { margin-bottom: 25px; }
        .help-section h3 { font-family: 'Orbitron', monospace; font-size: 14px; color: #ff3366; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 2px; }
        .help-row { display: flex; align-items: center; gap: 15px; margin-bottom: 8px; color: rgba(255,255,255,0.8); font-size: 15px; }
        .help-key { background: rgba(0,255,200,0.15); border: 1px solid rgba(0,255,200,0.4); border-radius: 6px; padding: 6px 12px; font-family: 'Orbitron', monospace; font-size: 12px; color: #00ffc8; min-width: 80px; text-align: center; }
        .help-close { background: transparent; border: 1px solid rgba(255,255,255,0.3); border-radius: 8px; padding: 12px 30px; font-family: 'Orbitron', monospace; font-size: 14px; color: #fff; cursor: pointer; margin-top: 20px; width: 100%; transition: all 0.3s; }
        .help-close:hover { border-color: #00ffc8; color: #00ffc8; }
        
        /* ===== PAUSE MENU ===== */
        #pauseMenu { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 2500; }
        #pauseMenu.visible { display: flex; }
        .pause-panel { text-align: center; }
        .pause-title { font-family: 'Orbitron', monospace; font-size: 48px; color: #00ffc8; margin-bottom: 40px; }
        .pause-btn { display: block; background: rgba(0,0,0,0.5); border: 2px solid rgba(0,255,200,0.3); border-radius: 10px; padding: 15px 50px; margin: 15px auto; font-family: 'Orbitron', monospace; font-size: 16px; color: #00ffc8; cursor: pointer; transition: all 0.3s; min-width: 250px; }
        .pause-btn:hover { border-color: #00ffc8; background: rgba(0,255,200,0.1); }
        
        /* ===== GAME MODE HUD ===== */
        #modeHud { position: fixed; top: 80px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); border: 1px solid rgba(0,255,200,0.3); border-radius: 10px; padding: 15px 30px; z-index: 100; text-align: center; display: none; }
        #modeHud.visible { display: block; }
        .mode-timer { font-family: 'Orbitron', monospace; font-size: 36px; color: #00ffc8; }
        .mode-info { font-size: 14px; color: rgba(255,255,255,0.6); margin-top: 5px; }
        .checkpoint-count { font-family: 'Orbitron', monospace; color: #ff3366; }
        
        /* ===== CHECKPOINT MARKERS ===== */
        .checkpoint-marker { position: absolute; width: 30px; height: 30px; border: 3px solid #ff3366; border-radius: 50%; pointer-events: none; animation: checkpointPulse 1s ease-in-out infinite; }
        @keyframes checkpointPulse { 0%, 100% { box-shadow: 0 0 10px #ff3366; } 50% { box-shadow: 0 0 25px #ff3366, 0 0 40px rgba(255,51,102,0.5); } }
        
        /* ===== GAME OVER / RESULTS ===== */
        #resultsScreen { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 2800; }
        #resultsScreen.visible { display: flex; }
        .results-panel { background: linear-gradient(135deg, rgba(20,20,30,0.98) 0%, rgba(10,10,20,0.98) 100%); border: 1px solid rgba(0,255,200,0.3); border-radius: 16px; padding: 40px 60px; text-align: center; }
        .results-title { font-family: 'Orbitron', monospace; font-size: 32px; color: #00ffc8; margin-bottom: 30px; }
        .results-time { font-family: 'Orbitron', monospace; font-size: 56px; color: #fff; margin-bottom: 10px; }
        .results-label { font-size: 14px; color: rgba(255,255,255,0.5); margin-bottom: 30px; }
        .results-btn { background: linear-gradient(135deg, #00ffc8 0%, #00aa88 100%); border: none; border-radius: 10px; padding: 15px 40px; font-family: 'Orbitron', monospace; font-size: 16px; color: #000; cursor: pointer; margin: 10px; transition: all 0.3s; }
        .results-btn:hover { transform: scale(1.05); }
        .results-btn.secondary { background: transparent; border: 1px solid rgba(255,255,255,0.3); color: #fff; }
        
        /* ===== EXISTING GAME STYLES ===== */
        #gameCanvas { display: block; cursor: grab; }
        #gameCanvas:active { cursor: grabbing; }
        #hud { position: fixed; top: 0; left: 0; right: 0; padding: 20px 30px; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 100; }
        .hud-panel { background: linear-gradient(135deg, rgba(0,0,0,0.85) 0%, rgba(20,20,30,0.95) 100%); border: 1px solid rgba(0, 255, 200, 0.3); border-radius: 8px; padding: 15px 25px; backdrop-filter: blur(10px); }
        .speed-display { text-align: center; }
        .speed-value { font-family: 'Orbitron', monospace; font-size: 48px; font-weight: 900; color: #00ffc8; text-shadow: 0 0 10px #00ffc8, 0 0 20px #00ffc8; line-height: 1; transition: color 0.2s; }
        .speed-value.speeding { color: #ff3366; text-shadow: 0 0 10px #ff3366, 0 0 20px #ff3366; }
        .speed-label { font-size: 14px; color: rgba(255,255,255,0.5); text-transform: uppercase; letter-spacing: 3px; margin-top: 5px; }
        .speed-limit { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); font-size: 12px; color: rgba(255,255,255,0.4); }
        .speed-limit-value { font-family: 'Orbitron', monospace; font-size: 18px; color: #fff; margin-left: 5px; }
        .info-panel { text-align: right; min-width: 260px; }
        .street-name { font-family: 'Orbitron', monospace; font-size: 18px; color: #00ffc8; margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid rgba(0, 255, 200, 0.2); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .info-row { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 8px; font-size: 14px; }
        .info-label { color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 1px; }
        .info-value { color: #00ffc8; font-family: 'Orbitron', monospace; font-weight: 700; }
        .status-row { display: flex; gap: 15px; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1); }
        .status-indicator { display: flex; align-items: center; gap: 6px; font-size: 11px; color: rgba(255,255,255,0.3); text-transform: uppercase; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: rgba(255,255,255,0.2); transition: all 0.2s; }
        .status-dot.active { background: #00ffc8; box-shadow: 0 0 10px #00ffc8; }
        .status-dot.warning { background: #ff3366; box-shadow: 0 0 10px #ff3366; }
        
        /* Direction indicators */
        .direction-indicator { position: fixed; width: 40px; height: 40px; pointer-events: none; z-index: 150; display: flex; align-items: center; justify-content: center; }
        .direction-arrow { font-size: 24px; filter: drop-shadow(0 0 8px currentColor); }
        .direction-indicator.destination { color: #ffcc00; }
        .direction-indicator.destination.complete { color: #00ff88; }
        .direction-indicator.checkpoint { color: #ff3366; }
        .direction-distance { position: absolute; bottom: -18px; font-family: 'Orbitron', monospace; font-size: 10px; white-space: nowrap; text-shadow: 0 0 5px #000, 0 0 10px #000; }
        #minimap { position: fixed; bottom: 20px; left: 20px; width: 180px; height: 180px; background: radial-gradient(ellipse at center, rgba(10, 15, 20, 0.95) 0%, rgba(5, 10, 15, 0.98) 100%); border: 1px solid rgba(0, 255, 200, 0.3); border-radius: 8px; z-index: 100; }
        
        /* Button stack */
        .btn-stack { position: fixed; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; z-index: 100; }
        .game-btn { background: linear-gradient(135deg, rgba(0, 255, 200, 0.15) 0%, rgba(0, 200, 150, 0.25) 100%); border: 1px solid rgba(0, 255, 200, 0.4); border-radius: 8px; padding: 10px 16px; color: #00ffc8; font-family: 'Orbitron', monospace; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; cursor: pointer; transition: all 0.3s ease; white-space: nowrap; }
        .game-btn:hover { background: rgba(0, 255, 200, 0.25); box-shadow: 0 0 15px rgba(0, 255, 200, 0.3); }
        .game-btn.police { background: linear-gradient(135deg, rgba(255, 50, 50, 0.15) 0%, rgba(50, 50, 255, 0.15) 100%); border-color: rgba(255, 100, 100, 0.4); color: #ff6666; }
        .game-btn.police.active { background: linear-gradient(135deg, rgba(255, 50, 50, 0.3) 0%, rgba(50, 50, 255, 0.3) 100%); border-color: #ff3333; }
        .game-btn.location { background: linear-gradient(135deg, rgba(255, 200, 50, 0.15) 0%, rgba(200, 150, 50, 0.2) 100%); border-color: rgba(255, 200, 50, 0.4); color: #ffcc44; }
        .game-btn.map { background: linear-gradient(135deg, rgba(100, 200, 100, 0.15) 0%, rgba(50, 150, 50, 0.2) 100%); border-color: rgba(100, 200, 100, 0.4); color: #66cc66; }
        
        .attribution { position: fixed; bottom: 5px; left: 50%; transform: translateX(-50%); font-size: 10px; color: rgba(255,255,255,0.2); z-index: 10; }
        .attribution a { color: rgba(255,255,255,0.3); }
        
        /* Controls Legend */
        #controlsLegend { position: fixed; bottom: 20px; left: 20px; background: linear-gradient(135deg, rgba(0,0,0,0.85) 0%, rgba(20,20,30,0.95) 100%); border: 1px solid rgba(0, 255, 200, 0.2); border-radius: 8px; padding: 12px 16px; z-index: 100; display: none; }
        #controlsLegend.visible { display: block; }
        .legend-title { font-family: 'Orbitron', monospace; font-size: 11px; color: #00ffc8; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 8px; }
        .legend-item { display: flex; align-items: center; gap: 8px; margin-bottom: 4px; font-size: 12px; color: rgba(255,255,255,0.6); }
        .legend-key { background: rgba(0, 255, 200, 0.15); border: 1px solid rgba(0, 255, 200, 0.3); border-radius: 3px; padding: 1px 6px; font-family: 'Orbitron', monospace; font-size: 10px; color: #00ffc8; min-width: 20px; text-align: center; }
    </style>
</head>
<body>
    <!-- TITLE SCREEN -->
    <div id="titleScreen">
        <div class="title-logo">STREET RACER</div>
        <div class="title-subtitle">Open World Driving</div>
        
        <div class="menu-section">
            <div class="menu-label">Select City</div>
            <div class="location-select">
                <div class="location-btn selected" data-location="baltimore">
                    <div class="city">Baltimore</div>
                    <div class="state">Maryland</div>
                </div>
                <div class="location-btn" data-location="hollywood">
                    <div class="city">Hollywood</div>
                    <div class="state">California</div>
                </div>
            </div>
        </div>
        
        <div class="menu-section">
            <div class="menu-label">Game Mode</div>
            <div class="mode-select">
                <div class="mode-btn selected" data-mode="freeRoam">
                    <div class="mode-icon">üöó</div>
                    <div class="mode-name">Free Roam</div>
                    <div class="mode-desc">Explore the city</div>
                </div>
                <div class="mode-btn" data-mode="timeTrial">
                    <div class="mode-icon">‚è±Ô∏è</div>
                    <div class="mode-name">Time Trial</div>
                    <div class="mode-desc">Race to destination</div>
                </div>
                <div class="mode-btn" data-mode="checkpoint">
                    <div class="mode-icon">üèÅ</div>
                    <div class="mode-name">Checkpoints</div>
                    <div class="mode-desc">Collect all markers</div>
                </div>
            </div>
        </div>
        
        <button class="start-btn" id="startBtn">Start Game</button>
        
        <div class="title-footer">
            <a href="#" id="howToPlayBtn">How to Play</a>
            <div class="version">v1.0 ‚Ä¢ Map data ¬© OpenStreetMap contributors</div>
        </div>
    </div>
    
    <!-- HOW TO PLAY -->
    <div id="howToPlay">
        <div class="help-panel">
            <div class="help-title">How to Play</div>
            
            <div class="help-section">
                <h3>Driving Controls</h3>
                <div class="help-row"><span class="help-key">W / ‚Üë</span> Accelerate</div>
                <div class="help-row"><span class="help-key">S / ‚Üì</span> Brake / Reverse</div>
                <div class="help-row"><span class="help-key">A / ‚Üë</span> Turn Left</div>
                <div class="help-row"><span class="help-key">D / ‚Üí</span> Turn Right</div>
                <div class="help-row"><span class="help-key">SPACE</span> Handbrake</div>
                <div class="help-row"><span class="help-key">CTRL</span> Boost</div>
            </div>
            
            <div class="help-section">
                <h3>Camera & Map</h3>
                <div class="help-row"><span class="help-key">Mouse Drag</span> Pan camera</div>
                <div class="help-row"><span class="help-key">Scroll / +‚àí</span> Zoom in/out</div>
                <div class="help-row"><span class="help-key">R</span> Reset zoom</div>
            </div>
            
            <div class="help-section">
                <h3>Special</h3>
                <div class="help-row"><span class="help-key">SHIFT</span> Off-road mode (leave streets)</div>
                <div class="help-row"><span class="help-key">ESC</span> Pause menu</div>
            </div>
            
            <div class="help-section">
                <h3>Tips</h3>
                <div class="help-row" style="display:block; line-height: 1.6;">
                    ‚Ä¢ Stay on roads for max speed<br>
                    ‚Ä¢ Watch your speed limit to avoid police<br>
                    ‚Ä¢ Use boost for quick getaways<br>
                    ‚Ä¢ In checkpoint mode, follow the markers
                </div>
            </div>
            
            <button class="help-close" id="closeHelp">Got It!</button>
        </div>
    </div>
    
    <!-- PAUSE MENU -->
    <div id="pauseMenu">
        <div class="pause-panel">
            <div class="pause-title">PAUSED</div>
            <button class="pause-btn" id="resumeBtn">Resume</button>
            <button class="pause-btn" id="restartBtn">Restart</button>
            <button class="pause-btn" id="helpBtn">How to Play</button>
            <button class="pause-btn" id="mainMenuBtn">Main Menu</button>
        </div>
    </div>
    
    <!-- RESULTS SCREEN -->
    <div id="resultsScreen">
        <div class="results-panel">
            <div class="results-title" id="resultsTitle">TIME TRIAL COMPLETE</div>
            <div class="results-time" id="resultsTime">00:00.00</div>
            <div class="results-label" id="resultsLabel">Total Time</div>
            <div>
                <button class="results-btn" id="playAgainBtn">Play Again</button>
                <button class="results-btn secondary" id="resultsMenuBtn">Main Menu</button>
            </div>
        </div>
    </div>
    
    <!-- GAME MODE HUD -->
    <div id="modeHud">
        <div class="mode-timer" id="modeTimer">00:00.00</div>
        <div class="mode-info" id="modeInfo">Free Roam</div>
    </div>
    
    <!-- GAME CANVAS & HUD -->
    <canvas id="gameCanvas"></canvas>
    <canvas id="minimap" width="180" height="180"></canvas>
    
    <!-- Direction indicators (arrows pointing to objectives) -->
    <div id="directionIndicators"></div>
    
    <div id="hud">
        <div class="hud-panel speed-display">
            <div class="speed-value" id="speedValue">0</div>
            <div class="speed-label">MPH</div>
            <div class="speed-limit">LIMIT <span class="speed-limit-value" id="speedLimitValue">--</span></div>
        </div>
        <div class="hud-panel info-panel">
            <div class="street-name" id="streetName">Loading...</div>
            <div class="info-row"><span class="info-label">Location</span><span class="info-value" id="locationValue">Baltimore, MD</span></div>
            <div class="info-row"><span class="info-label">Coords</span><span class="info-value" id="coordsValue">--</span></div>
            <div class="info-row"><span class="info-label">Heading</span><span class="info-value" id="headingValue">N</span></div>
            <div class="status-row">
                <div class="status-indicator"><div class="status-dot" id="brakingDot"></div><span>BRAKE</span></div>
                <div class="status-indicator"><div class="status-dot" id="boostDot"></div><span>BOOST</span></div>
                <div class="status-indicator"><div class="status-dot" id="offRoadModeDot"></div><span>OFF-ROAD</span></div>
            </div>
        </div>
    </div>
    
    <div class="btn-stack">
        <button class="game-btn location" id="locationBtn">üìç Hollywood</button>
        <button class="game-btn map" id="mapToggleBtn">üó∫Ô∏è Street View</button>
        <button class="game-btn police" id="policeBtn">üöî Police Chase</button>
        <button class="game-btn" id="respawnBtn">üîÑ Respawn</button>
        <button class="game-btn" id="reloadBtn">‚ü≥ Reload Roads</button>
    </div>
    
    <!-- Controls Legend (always visible during game) -->
    <div id="controlsLegend">
        <div class="legend-title">Controls</div>
        <div class="legend-item"><span class="legend-key">W</span><span class="legend-key">‚Üë</span> Accelerate</div>
        <div class="legend-item"><span class="legend-key">S</span><span class="legend-key">‚Üì</span> Brake/Reverse</div>
        <div class="legend-item"><span class="legend-key">A</span><span class="legend-key">‚Üê</span> Turn Left</div>
        <div class="legend-item"><span class="legend-key">D</span><span class="legend-key">‚Üí</span> Turn Right</div>
        <div class="legend-item"><span class="legend-key">Space</span> Handbrake</div>
        <div class="legend-item"><span class="legend-key">Ctrl</span> Boost</div>
        <div class="legend-item"><span class="legend-key">Shift</span> Off-Road</div>
        <div class="legend-item"><span class="legend-key">Drag</span> Pan Camera</div>
        <div class="legend-item"><span class="legend-key">Scroll</span> Zoom</div>
        <div class="legend-item"><span class="legend-key">R</span> Reset Zoom</div>
        <div class="legend-item"><span class="legend-key">Esc</span> Pause</div>
    </div>
    
    <div class="attribution">Map data ¬© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors</div>

    <script>
    // ============== LOCATIONS ==============
    const LOCATIONS = {
        baltimore: { name: 'Baltimore, MD', lat: 39.2904, lon: -76.6122 },
        hollywood: { name: 'Hollywood, CA', lat: 34.1016, lon: -118.3267 }
    };

    // ============== CONFIG ==============
    const CONFIG = {
        startLat: 39.2904, startLon: -76.6122, loadRadius: 0.035,
        currentLocation: 'baltimore',
        maxSpeed: 240, acceleration: 50, boostAcceleration: 200, brakeForce: 300, friction: 45, turnSpeed: 3.8,
        offRoadFriction: 250, offRoadMaxSpeed: 40,
        baseCameraZoom: 1.5, minCameraZoom: 0.1, maxCameraZoom: 8, speedZoomFactor: 0.002, lookAheadFactor: 0.3,
        roadColor: '#2a5a6a', roadGlow: '#00ffcc', carColor: '#ff3366', backgroundColor: '#0a1215',
        skidMarkColor: 'rgba(30, 30, 30, 0.8)', maxSkidMarks: 500,
        policeSpeed: 180, policeAccel: 80, policeTurnSpeed: 4.0, policeChaseDistance: 800,
        tileSize: 256, tileZoom: 18,
        satelliteServer: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile',
        streetServer: 'https://tile.openstreetmap.org',
        tilePreloadRadius: 3,
        checkpointRadius: 25,
        timeTrialDuration: 120 // seconds
    };

    // ============== GAME STATE ==============
    const state = {
        car: { x: 0, y: 0, angle: 0, speed: 0, width: 12, height: 6, isOnRoad: true, wasOnRoad: true, currentRoad: null, isBraking: false, isSkidding: false, isOffRoadMode: false, isBoosting: false },
        camera: { x: 0, y: 0, zoom: 1.5, targetZoom: 1.5, lookAheadX: 0, lookAheadY: 0, manualZoom: false },
        roads: [], bounds: null, skidMarks: [], tiles: {}, keys: {}, lastTime: 0,
        policeEnabled: false, police: [],
        mapType: 'satellite',
        // Game mode state
        gameMode: 'freeRoam', // 'freeRoam', 'timeTrial', 'checkpoint'
        gameStarted: false,
        gamePaused: false,
        gameTimer: 0,
        checkpoints: [],
        checkpointsCollected: 0,
        totalCheckpoints: 8,
        // Time trial destination
        timeTrialDestination: null,
        timeTrialComplete: false
    };

    // ============== DOM ELEMENTS ==============
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimap');
    const minimapCtx = minimapCanvas.getContext('2d');

    // ============== COORDINATE FUNCTIONS ==============
    const SCALE = 100000;
    function geoToGame(lat, lon) { return { x: (lon - CONFIG.startLon) * SCALE * Math.cos(CONFIG.startLat * Math.PI / 180), y: -(lat - CONFIG.startLat) * SCALE }; }
    function gameToGeo(x, y) { return { lat: CONFIG.startLat - (y / SCALE), lon: CONFIG.startLon + (x / (SCALE * Math.cos(CONFIG.startLat * Math.PI / 180))) }; }
    function geoToTile(lat, lon, zoom) { const n = Math.pow(2, zoom); const x = Math.floor((lon + 180) / 360 * n); const latRad = lat * Math.PI / 180; const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n); return { x, y, z: zoom }; }
    function tileToGeo(x, y, zoom) { const n = Math.pow(2, zoom); const lon = x / n * 360 - 180; const latRad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))); return { lat: latRad * 180 / Math.PI, lon }; }

    // ============== TILE LOADING ==============
    function getTileKey(x, y, z) { return `${state.mapType}/${z}/${x}/${y}`; }
    function loadTile(x, y, z) {
        const key = getTileKey(x, y, z);
        if (state.tiles[key]) return;
        state.tiles[key] = { loading: true, img: null };
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => { state.tiles[key] = { loading: false, img: img }; };
        img.onerror = () => { state.tiles[key] = { loading: false, img: null, error: true }; };
        if (state.mapType === 'satellite') {
            img.src = `${CONFIG.satelliteServer}/${z}/${y}/${x}`;
        } else {
            img.src = `${CONFIG.streetServer}/${z}/${x}/${y}.png`;
        }
    }

    function getVisibleTiles() {
        const { width, height } = canvas; const cam = state.camera;
        const viewWidth = width / cam.zoom; const viewHeight = height / cam.zoom;
        const topLeft = gameToGeo(cam.x - viewWidth/2, cam.y - viewHeight/2);
        const bottomRight = gameToGeo(cam.x + viewWidth/2, cam.y + viewHeight/2);
        const zoom = CONFIG.tileZoom;
        const minTile = geoToTile(topLeft.lat, topLeft.lon, zoom);
        const maxTile = geoToTile(bottomRight.lat, bottomRight.lon, zoom);
        const tiles = [];
        const preload = CONFIG.tilePreloadRadius;
        for (let tx = minTile.x - preload; tx <= maxTile.x + preload; tx++) {
            for (let ty = minTile.y - preload; ty <= maxTile.y + preload; ty++) { tiles.push({ x: tx, y: ty, z: zoom }); }
        }
        return tiles;
    }

    function drawMapTiles() {
        const visibleTiles = getVisibleTiles();
        visibleTiles.forEach(({ x, y, z }) => {
            loadTile(x, y, z);
            const key = getTileKey(x, y, z);
            const tile = state.tiles[key];
            if (tile && tile.img && !tile.loading) {
                const topLeftGeo = tileToGeo(x, y, z);
                const bottomRightGeo = tileToGeo(x + 1, y + 1, z);
                const topLeftGame = geoToGame(topLeftGeo.lat, topLeftGeo.lon);
                const bottomRightGame = geoToGame(bottomRightGeo.lat, bottomRightGeo.lon);
                ctx.globalAlpha = state.mapType === 'satellite' ? 0.9 : 0.7;
                ctx.drawImage(tile.img, topLeftGame.x, topLeftGame.y, bottomRightGame.x - topLeftGame.x, bottomRightGame.y - topLeftGame.y);
                ctx.globalAlpha = 1;
            }
        });
    }

    // ============== SAMPLE ROADS ==============
    const SAMPLE_ROADS = {
        baltimore: [
            { type: 'primary', name: 'Pratt Street', speedLimit: 30, coords: [[39.2867, -76.6280], [39.2867, -76.6234], [39.2867, -76.6180], [39.2868, -76.6120], [39.2869, -76.6060]] },
            { type: 'primary', name: 'Light Street', speedLimit: 35, coords: [[39.2780, -76.6147], [39.2820, -76.6146], [39.2860, -76.6145], [39.2900, -76.6144], [39.2940, -76.6143]] },
            { type: 'primary', name: 'Charles Street', speedLimit: 35, coords: [[39.2790, -76.6155], [39.2830, -76.6155], [39.2870, -76.6154], [39.2910, -76.6154], [39.2950, -76.6153]] },
            { type: 'secondary', name: 'Lombard Street', speedLimit: 30, coords: [[39.2887, -76.6280], [39.2887, -76.6220], [39.2887, -76.6160], [39.2888, -76.6100]] },
            { type: 'secondary', name: 'Baltimore Street', speedLimit: 30, coords: [[39.2905, -76.6275], [39.2905, -76.6215], [39.2905, -76.6155], [39.2906, -76.6095]] },
            { type: 'secondary', name: 'Fayette Street', speedLimit: 30, coords: [[39.2922, -76.6270], [39.2922, -76.6210], [39.2922, -76.6150], [39.2923, -76.6090]] },
            { type: 'secondary', name: 'Calvert Street', speedLimit: 30, coords: [[39.2795, -76.6115], [39.2835, -76.6115], [39.2875, -76.6114], [39.2915, -76.6114]] },
            { type: 'secondary', name: 'Howard Street', speedLimit: 30, coords: [[39.2785, -76.6205], [39.2825, -76.6205], [39.2865, -76.6204], [39.2905, -76.6204]] },
            { type: 'tertiary', name: 'Gay Street', speedLimit: 25, coords: [[39.2800, -76.6085], [39.2840, -76.6085], [39.2880, -76.6084], [39.2920, -76.6084]] },
            { type: 'primary', name: 'Key Highway', speedLimit: 35, coords: [[39.2740, -76.6080], [39.2770, -76.6120], [39.2800, -76.6155], [39.2830, -76.6180]] },
        ],
        hollywood: [
            { type: 'primary', name: 'Hollywood Boulevard', speedLimit: 35, coords: [[34.1016, -118.3400], [34.1016, -118.3320], [34.1016, -118.3240], [34.1017, -118.3160], [34.1017, -118.3080]] },
            { type: 'primary', name: 'Sunset Boulevard', speedLimit: 40, coords: [[34.0976, -118.3400], [34.0977, -118.3320], [34.0977, -118.3240], [34.0978, -118.3160], [34.0979, -118.3080]] },
            { type: 'secondary', name: 'Highland Avenue', speedLimit: 35, coords: [[34.0920, -118.3386], [34.0960, -118.3386], [34.1000, -118.3385], [34.1040, -118.3385], [34.1080, -118.3384]] },
            { type: 'secondary', name: 'Vine Street', speedLimit: 30, coords: [[34.0920, -118.3267], [34.0960, -118.3267], [34.1000, -118.3266], [34.1040, -118.3266], [34.1080, -118.3265]] },
            { type: 'secondary', name: 'Cahuenga Boulevard', speedLimit: 35, coords: [[34.0930, -118.3300], [34.0970, -118.3295], [34.1010, -118.3290], [34.1050, -118.3285]] },
            { type: 'tertiary', name: 'Selma Avenue', speedLimit: 25, coords: [[34.0990, -118.3380], [34.0990, -118.3310], [34.0990, -118.3240], [34.0991, -118.3170]] },
            { type: 'secondary', name: 'La Brea Avenue', speedLimit: 35, coords: [[34.0900, -118.3440], [34.0950, -118.3439], [34.1000, -118.3438], [34.1050, -118.3437]] },
            { type: 'secondary', name: 'Franklin Avenue', speedLimit: 30, coords: [[34.1050, -118.3400], [34.1050, -118.3320], [34.1050, -118.3240], [34.1051, -118.3160]] },
            { type: 'primary', name: 'Santa Monica Boulevard', speedLimit: 40, coords: [[34.0905, -118.3400], [34.0906, -118.3320], [34.0906, -118.3240], [34.0907, -118.3160]] },
        ]
    };

    function loadSampleRoads() {
        state.roads = [];
        const sampleData = SAMPLE_ROADS[CONFIG.currentLocation] || SAMPLE_ROADS.baltimore;
        sampleData.forEach(road => {
            const points = road.coords.map(([lat, lon]) => geoToGame(lat, lon));
            let width = 8;
            if (road.type === 'primary') width = 14;
            else if (road.type === 'secondary') width = 12;
            else if (road.type === 'tertiary') width = 10;
            state.roads.push({ points, width, type: road.type, name: road.name, speedLimit: road.speedLimit });
        });
        calculateBounds();
    }

    function calculateBounds() {
        if (state.roads.length === 0) return;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        state.roads.forEach(road => { road.points.forEach(p => { minX = Math.min(minX, p.x); maxX = Math.max(maxX, p.x); minY = Math.min(minY, p.y); maxY = Math.max(maxY, p.y); }); });
        state.bounds = { minX, maxX, minY, maxY };
    }

    async function loadRoads() {
        state.tiles = {};
        
        const minLat = CONFIG.startLat - CONFIG.loadRadius;
        const maxLat = CONFIG.startLat + CONFIG.loadRadius;
        const minLon = CONFIG.startLon - CONFIG.loadRadius;
        const maxLon = CONFIG.startLon + CONFIG.loadRadius;
        
        const query = `[out:json][timeout:30];(way["highway"~"^(motorway|motorway_link|trunk|trunk_link|primary|primary_link|secondary|secondary_link|tertiary|tertiary_link|residential|unclassified|living_street)$"](${minLat},${minLon},${maxLat},${maxLon}););out body;>;out skel qt;`;
        
        try {
            const res = await fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: 'data=' + encodeURIComponent(query) });
            if (!res.ok) throw new Error('API request failed');
            const data = await res.json();
            
            // Process nodes
            const nodes = {};
            data.elements.forEach(el => { if (el.type === 'node') nodes[el.id] = { lat: el.lat, lon: el.lon }; });
            
            // Process ways
            state.roads = [];
            data.elements.forEach(el => {
                if (el.type === 'way' && el.nodes) {
                    const points = el.nodes.map(nodeId => nodes[nodeId]).filter(n => n).map(n => geoToGame(n.lat, n.lon));
                    if (points.length >= 2) {
                        const highway = el.tags?.highway || 'residential';
                        let width = 8, defaultSpeed = 25;
                        if (highway.includes('motorway')) { width = 18; defaultSpeed = 65; }
                        else if (highway.includes('trunk')) { width = 16; defaultSpeed = 55; }
                        else if (highway.includes('primary')) { width = 14; defaultSpeed = 40; }
                        else if (highway.includes('secondary')) { width = 12; defaultSpeed = 35; }
                        else if (highway.includes('tertiary')) { width = 10; defaultSpeed = 30; }
                        const name = el.tags?.name || `${highway.charAt(0).toUpperCase() + highway.slice(1).replace('_', ' ')}`;
                        const speedLimit = el.tags?.maxspeed ? parseInt(el.tags.maxspeed) : defaultSpeed;
                        state.roads.push({ points, width, type: highway, name, speedLimit });
                    }
                }
            });
            
            if (state.roads.length === 0) loadSampleRoads();
            else calculateBounds();
            console.log(`Loaded ${state.roads.length} roads from OpenStreetMap`);
        } catch (e) {
            console.log('Using sample roads:', e);
            loadSampleRoads();
        }
        
        respawnCar();
        if (state.gameMode === 'checkpoint') generateCheckpoints();
        if (state.gameMode === 'timeTrial') generateTimeTrialDestination();
    }

    // ============== CAR & PHYSICS ==============
    function respawnCar() {
        if (state.roads.length > 0 && state.roads[0].points.length > 0) {
            const startRoad = state.roads[0];
            state.car.x = startRoad.points[0].x;
            state.car.y = startRoad.points[0].y;
            if (startRoad.points.length > 1) {
                state.car.angle = Math.atan2(startRoad.points[1].y - startRoad.points[0].y, startRoad.points[1].x - startRoad.points[0].x);
            }
            state.car.speed = 0;
            state.camera.x = state.car.x;
            state.camera.y = state.car.y;
        }
    }

    function nearestPointOnSegment(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1, dy = y2 - y1, lengthSquared = dx * dx + dy * dy;
        if (lengthSquared === 0) return { point: { x: x1, y: y1 }, distance: Math.sqrt((px - x1) ** 2 + (py - y1) ** 2) };
        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
        t = Math.max(0, Math.min(1, t));
        const nearestX = x1 + t * dx, nearestY = y1 + t * dy;
        return { point: { x: nearestX, y: nearestY }, distance: Math.sqrt((px - nearestX) ** 2 + (py - nearestY) ** 2), t };
    }

    function getRoadDirection(road, carX, carY) {
        if (!road || road.points.length < 2) return null;
        let nearestDist = Infinity, nearestSegment = 0;
        for (let i = 0; i < road.points.length - 1; i++) {
            const p1 = road.points[i], p2 = road.points[i + 1];
            const result = nearestPointOnSegment(carX, carY, p1.x, p1.y, p2.x, p2.y);
            if (result.distance < nearestDist) { nearestDist = result.distance; nearestSegment = i; }
        }
        const p1 = road.points[nearestSegment], p2 = road.points[nearestSegment + 1];
        return Math.atan2(p2.y - p1.y, p2.x - p1.x);
    }

    function findNearestRoad(x, y) {
        let nearestRoad = null, nearestDistance = Infinity, nearestPoint = null;
        state.roads.forEach(road => {
            for (let i = 0; i < road.points.length - 1; i++) {
                const p1 = road.points[i], p2 = road.points[i + 1];
                const result = nearestPointOnSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                if (result.distance < nearestDistance) { nearestDistance = result.distance; nearestRoad = road; nearestPoint = result.point; }
            }
        });
        return { road: nearestRoad, distance: nearestDistance, point: nearestPoint };
    }

    // ============== CHECKPOINTS ==============
    function generateCheckpoints() {
        state.checkpoints = [];
        state.checkpointsCollected = 0;
        
        // Place checkpoints at random road intersections/points
        const allPoints = [];
        state.roads.forEach(road => {
            road.points.forEach((p, i) => {
                if (i % 2 === 0) allPoints.push({ x: p.x, y: p.y }); // Every other point
            });
        });
        
        // Shuffle and pick N checkpoints
        for (let i = allPoints.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allPoints[i], allPoints[j]] = [allPoints[j], allPoints[i]];
        }
        
        state.checkpoints = allPoints.slice(0, state.totalCheckpoints).map((p, i) => ({
            x: p.x, y: p.y, collected: false, index: i + 1
        }));
    }

    function checkCheckpointCollision() {
        const car = state.car;
        state.checkpoints.forEach(cp => {
            if (cp.collected) return;
            const dist = Math.sqrt((car.x - cp.x) ** 2 + (car.y - cp.y) ** 2);
            if (dist < CONFIG.checkpointRadius) {
                cp.collected = true;
                state.checkpointsCollected++;
                
                // Check if all collected
                if (state.checkpointsCollected >= state.totalCheckpoints) {
                    endGame();
                }
            }
        });
    }

    // ============== TIME TRIAL DESTINATION ==============
    function generateTimeTrialDestination() {
        state.timeTrialDestination = null;
        state.timeTrialComplete = false;
        
        if (!state.bounds || state.roads.length === 0) return;
        
        // Find a point on the opposite side of the map from spawn
        const car = state.car;
        let farthestPoint = null;
        let farthestDist = 0;
        
        // Search through all road points for the farthest one
        state.roads.forEach(road => {
            road.points.forEach(p => {
                const dist = Math.sqrt((p.x - car.x) ** 2 + (p.y - car.y) ** 2);
                if (dist > farthestDist) {
                    farthestDist = dist;
                    farthestPoint = { x: p.x, y: p.y };
                }
            });
        });
        
        if (farthestPoint) {
            state.timeTrialDestination = farthestPoint;
            console.log('Time trial destination set at distance:', farthestDist);
        }
    }

    function checkTimeTrialDestination() {
        if (!state.timeTrialDestination || state.timeTrialComplete) return;
        
        const car = state.car;
        const dest = state.timeTrialDestination;
        const dist = Math.sqrt((car.x - dest.x) ** 2 + (car.y - dest.y) ** 2);
        
        if (dist < CONFIG.checkpointRadius * 1.5) {
            // Reached destination! Stop timer but don't end game
            state.timeTrialComplete = true;
        }
    }

    // ============== POLICE ==============
    function spawnPolice() {
        state.police = [];
        const car = state.car;
        for (let i = 0; i < 2; i++) {
            const spawnDistance = 300 + i * 200;
            const spawnAngle = car.angle + Math.PI + (i === 0 ? 0.5 : -0.5);
            let spawnX = car.x + Math.cos(spawnAngle) * spawnDistance;
            let spawnY = car.y + Math.sin(spawnAngle) * spawnDistance;
            const nearestRoad = findNearestRoad(spawnX, spawnY);
            if (nearestRoad.point) { spawnX = nearestRoad.point.x; spawnY = nearestRoad.point.y; }
            state.police.push({ x: spawnX, y: spawnY, angle: car.angle, speed: 0, width: 14, height: 7, sirenPhase: i * Math.PI, isChasing: false });
        }
    }

    function updatePolice(dt) {
        if (!state.policeEnabled || state.police.length === 0) return;
        const car = state.car;
        const mph = Math.abs(car.speed * 0.5);
        const speedLimit = car.currentRoad?.speedLimit || 25;
        const isSpeeding = mph > speedLimit;
        
        state.police.forEach(cop => {
            cop.sirenPhase += dt * 10;
            const dx = car.x - cop.x, dy = car.y - cop.y;
            const distToPlayer = Math.sqrt(dx * dx + dy * dy);
            
            if (isSpeeding && distToPlayer < CONFIG.policeChaseDistance) cop.isChasing = true;
            if (!isSpeeding && distToPlayer < 100) cop.isChasing = false;
            
            if (cop.isChasing) {
                const targetAngle = Math.atan2(dy, dx);
                let angleDiff = targetAngle - cop.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                cop.angle += angleDiff * CONFIG.policeTurnSpeed * dt;
                if (distToPlayer > 50) cop.speed += CONFIG.policeAccel * dt;
                else cop.speed *= 0.95;
                cop.speed = Math.min(cop.speed, CONFIG.policeSpeed);
            } else {
                cop.speed *= 0.98;
                if (cop.speed < 1) cop.speed = 0;
            }
            
            const newX = cop.x + Math.cos(cop.angle) * cop.speed * dt;
            const newY = cop.y + Math.sin(cop.angle) * cop.speed * dt;
            const nearestRoad = findNearestRoad(newX, newY);
            if (nearestRoad.distance < 50 || cop.isChasing) { cop.x = newX; cop.y = newY; }
            else if (nearestRoad.point) { cop.x = nearestRoad.point.x; cop.y = nearestRoad.point.y; }
            
            if (distToPlayer < 20 && cop.isChasing) { car.speed *= 0.3; cop.speed = 0; }
        });
    }

    // ============== GAME FLOW ==============
    function startGame() {
        document.getElementById('titleScreen').classList.add('hidden');
        document.getElementById('controlsLegend').classList.add('visible');
        state.gameStarted = true;
        state.gamePaused = false;
        state.gameTimer = 0;
        state.timeTrialComplete = false;
        state.timeTrialDestination = null;
        
        // Set location
        const loc = LOCATIONS[CONFIG.currentLocation];
        CONFIG.startLat = loc.lat;
        CONFIG.startLon = loc.lon;
        document.getElementById('locationValue').textContent = loc.name;
        document.getElementById('locationBtn').textContent = 'üìç ' + (CONFIG.currentLocation === 'baltimore' ? 'Hollywood' : 'Baltimore');
        
        // Setup mode
        if (state.gameMode === 'checkpoint') {
            document.getElementById('modeHud').classList.add('visible');
            document.getElementById('modeInfo').textContent = `Checkpoints: 0/${state.totalCheckpoints}`;
        } else if (state.gameMode === 'timeTrial') {
            document.getElementById('modeHud').classList.add('visible');
            document.getElementById('modeInfo').textContent = 'Race to the destination!';
        } else {
            document.getElementById('modeHud').classList.remove('visible');
        }
        
        loadRoads();
        state.lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function pauseGame() {
        if (!state.gameStarted) return;
        state.gamePaused = true;
        document.getElementById('pauseMenu').classList.add('visible');
    }

    function resumeGame() {
        state.gamePaused = false;
        document.getElementById('pauseMenu').classList.remove('visible');
        state.lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function restartGame() {
        document.getElementById('pauseMenu').classList.remove('visible');
        document.getElementById('resultsScreen').classList.remove('visible');
        state.gamePaused = false;
        state.gameTimer = 0;
        state.checkpointsCollected = 0;
        state.timeTrialComplete = false;
        state.timeTrialDestination = null;
        state.police = [];
        state.policeEnabled = false;
        document.getElementById('policeBtn').classList.remove('active');
        
        if (state.gameMode === 'checkpoint') generateCheckpoints();
        if (state.gameMode === 'timeTrial') generateTimeTrialDestination();
        respawnCar();
        
        state.lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function endGame() {
        state.gamePaused = true;
        
        if (state.gameMode === 'checkpoint') {
            document.getElementById('resultsTitle').textContent = 'CHECKPOINTS COMPLETE!';
            document.getElementById('resultsTime').textContent = formatTime(state.gameTimer);
            document.getElementById('resultsLabel').textContent = 'Total Time';
        }
        
        document.getElementById('resultsScreen').classList.add('visible');
    }

    function goToMainMenu() {
        document.getElementById('pauseMenu').classList.remove('visible');
        document.getElementById('resultsScreen').classList.remove('visible');
        document.getElementById('modeHud').classList.remove('visible');
        document.getElementById('controlsLegend').classList.remove('visible');
        document.getElementById('titleScreen').classList.remove('hidden');
        state.gameStarted = false;
        state.gamePaused = false;
    }

    function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        const ms = Math.floor((seconds % 1) * 100);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
    }

    // ============== UPDATE ==============
    function update(dt) {
        if (state.gamePaused) return;
        
        const car = state.car, keys = state.keys;
        car.isOffRoadMode = keys['ShiftLeft'] || keys['ShiftRight'];
        car.isBoosting = keys['ControlLeft'] || keys['ControlRight'];

        const { road: nearestRoad, distance: nearestDistance, point: nearestPoint } = findNearestRoad(car.x, car.y);
        const effectiveRadius = nearestRoad ? nearestRoad.width / 2 + 12 : 25;
        
        if (car.wasOnRoad && nearestDistance > effectiveRadius + 8) car.isOnRoad = false;
        else if (!car.wasOnRoad && nearestDistance < effectiveRadius) car.isOnRoad = true;
        car.wasOnRoad = car.isOnRoad;
        car.currentRoad = nearestRoad;

        const currentMaxSpeed = car.isOnRoad ? CONFIG.maxSpeed : CONFIG.offRoadMaxSpeed;
        const currentFriction = car.isOnRoad ? CONFIG.friction : CONFIG.offRoadFriction;
        const currentAccel = car.isBoosting ? CONFIG.boostAcceleration : CONFIG.acceleration;

        car.isBraking = keys['Space'] || keys['KeyS'] || keys['ArrowDown'];
        if (keys['KeyW'] || keys['ArrowUp']) car.speed += currentAccel * dt;
        if (car.isBraking) car.speed -= CONFIG.brakeForce * dt;

        const turnAmount = CONFIG.turnSpeed * dt;
        const turnDir = car.speed >= 0 ? 1 : -1;
        const speedFactor = 1 - (Math.abs(car.speed) / CONFIG.maxSpeed) * 0.2;
        const isTurningLeft = keys['KeyA'] || keys['ArrowLeft'];
        const isTurningRight = keys['KeyD'] || keys['ArrowRight'];
        if (isTurningLeft) car.angle -= turnAmount * turnDir * speedFactor;
        if (isTurningRight) car.angle += turnAmount * turnDir * speedFactor;

        // Auto-straighten
        if (!isTurningLeft && !isTurningRight && Math.abs(car.speed) > 10 && nearestRoad && car.isOnRoad) {
            const roadDir = getRoadDirection(nearestRoad, car.x, car.y);
            if (roadDir !== null) {
                let angleDiff = roadDir - car.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                if (Math.abs(angleDiff) > Math.PI / 2) angleDiff = angleDiff > 0 ? angleDiff - Math.PI : angleDiff + Math.PI;
                car.angle += angleDiff * 0.03 * Math.min(1, Math.abs(car.speed) / 50);
            }
        }

        if (!keys['KeyW'] && !keys['ArrowUp'] && !keys['KeyS'] && !keys['ArrowDown'] && !car.isBraking) {
            car.speed = car.speed > 0 ? Math.max(0, car.speed - currentFriction * dt) : Math.min(0, car.speed + currentFriction * dt);
        }
        car.speed = Math.max(-currentMaxSpeed * 0.3, Math.min(currentMaxSpeed, car.speed));

        // Skid marks
        car.isSkidding = (car.isBraking && Math.abs(car.speed) > 30) || ((isTurningLeft || isTurningRight) && Math.abs(car.speed) > 60);
        if (car.isSkidding && state.skidMarks.length < CONFIG.maxSkidMarks) {
            const rearOffset = car.width * 0.4, sideOffset = car.height * 0.35;
            const cos = Math.cos(car.angle), sin = Math.sin(car.angle);
            state.skidMarks.push({ x: car.x - cos * rearOffset - sin * sideOffset, y: car.y - sin * rearOffset + cos * sideOffset, age: 0 });
            state.skidMarks.push({ x: car.x - cos * rearOffset + sin * sideOffset, y: car.y - sin * rearOffset - cos * sideOffset, age: 0 });
        }

        // Movement with road constraint
        let newX = car.x + Math.cos(car.angle) * car.speed * dt;
        let newY = car.y + Math.sin(car.angle) * car.speed * dt;
        
        if (!car.isOffRoadMode && state.roads.length > 0) {
            const newResult = findNearestRoad(newX, newY);
            const newEffectiveRadius = newResult.road ? newResult.road.width / 2 + 12 : 25;
            if (newResult.distance > newEffectiveRadius && newResult.point) {
                car.speed *= 0.5; // Crash penalty
                const pushDir = Math.atan2(car.y - newResult.point.y, car.x - newResult.point.x);
                newX = newResult.point.x + Math.cos(pushDir) * (newEffectiveRadius - 2);
                newY = newResult.point.y + Math.sin(pushDir) * (newEffectiveRadius - 2);
            }
        }
        
        car.x = newX;
        car.y = newY;

        // Camera
        const lookAheadX = Math.cos(car.angle) * Math.abs(car.speed) * CONFIG.lookAheadFactor;
        const lookAheadY = Math.sin(car.angle) * Math.abs(car.speed) * CONFIG.lookAheadFactor;
        state.camera.lookAheadX += (lookAheadX - state.camera.lookAheadX) * 0.05;
        state.camera.lookAheadY += (lookAheadY - state.camera.lookAheadY) * 0.05;
        state.camera.x += (car.x + state.camera.lookAheadX - state.camera.x) * 0.08;
        state.camera.y += (car.y + state.camera.lookAheadY - state.camera.y) * 0.08;
        if (!state.camera.manualZoom) {
            state.camera.targetZoom = Math.max(CONFIG.minCameraZoom, Math.min(CONFIG.maxCameraZoom, CONFIG.baseCameraZoom - Math.abs(car.speed) * CONFIG.speedZoomFactor));
        }
        state.camera.zoom += (state.camera.targetZoom - state.camera.zoom) * 0.08;

        // Update game timer
        if (state.gameMode === 'timeTrial') {
            // Timer counts UP until destination reached
            if (!state.timeTrialComplete) {
                state.gameTimer += dt;
                checkTimeTrialDestination();
            }
        } else if (state.gameMode === 'checkpoint') {
            state.gameTimer += dt;
            checkCheckpointCollision();
        }

        updatePolice(dt);
        updateHUD();
    }

    function updateHUD() {
        const car = state.car;
        const mph = Math.abs(Math.round(car.speed * 0.5));
        const speedEl = document.getElementById('speedValue');
        speedEl.textContent = mph;
        const speedLimit = car.currentRoad?.speedLimit || 25;
        speedEl.classList.toggle('speeding', mph > speedLimit);
        document.getElementById('speedLimitValue').textContent = speedLimit;
        document.getElementById('streetName').textContent = car.currentRoad?.name || 'Unknown Road';
        const geo = gameToGeo(car.x, car.y);
        document.getElementById('coordsValue').textContent = `${geo.lat.toFixed(4)}¬∞N ${Math.abs(geo.lon).toFixed(4)}¬∞W`;
        let heading = (car.angle * 180 / Math.PI + 90) % 360;
        if (heading < 0) heading += 360;
        const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
        document.getElementById('headingValue').textContent = `${dirs[Math.round(heading / 45) % 8]} ${Math.round(heading)}¬∞`;
        document.getElementById('brakingDot').classList.toggle('active', car.isBraking);
        document.getElementById('boostDot').classList.toggle('active', car.isBoosting);
        document.getElementById('offRoadModeDot').classList.toggle('active', car.isOffRoadMode);
        
        // Mode HUD
        if (state.gameMode === 'timeTrial') {
            document.getElementById('modeTimer').textContent = formatTime(state.gameTimer);
            if (state.timeTrialComplete) {
                document.getElementById('modeInfo').textContent = 'üèÅ FINISH!';
            } else {
                document.getElementById('modeInfo').textContent = 'Race to the destination!';
            }
        } else if (state.gameMode === 'checkpoint') {
            document.getElementById('modeTimer').textContent = formatTime(state.gameTimer);
            document.getElementById('modeInfo').innerHTML = `Checkpoints: <span class="checkpoint-count">${state.checkpointsCollected}/${state.totalCheckpoints}</span>`;
        }
    }

    // ============== DIRECTION INDICATORS ==============
    function updateDirectionIndicators() {
        const container = document.getElementById('directionIndicators');
        container.innerHTML = '';
        
        const { width, height } = canvas;
        const cam = state.camera;
        const margin = 60; // Distance from screen edge
        const car = state.car;
        
        // Helper: check if point is on screen and get screen position
        function getScreenPos(worldX, worldY) {
            const screenX = width / 2 + (worldX - cam.x) * cam.zoom;
            const screenY = height / 2 + (worldY - cam.y) * cam.zoom;
            return { x: screenX, y: screenY };
        }
        
        // Helper: check if position is within visible screen
        function isOnScreen(screenX, screenY, buffer = 50) {
            return screenX >= buffer && screenX <= width - buffer && 
                   screenY >= buffer && screenY <= height - buffer;
        }
        
        // Helper: create direction indicator
        function createIndicator(targetX, targetY, type, label, isComplete = false) {
            const screenPos = getScreenPos(targetX, targetY);
            
            // If on screen, don't show indicator
            if (isOnScreen(screenPos.x, screenPos.y)) return;
            
            // Calculate angle from screen center to target
            const angle = Math.atan2(screenPos.y - height / 2, screenPos.x - width / 2);
            
            // Calculate position on screen edge
            let indicatorX, indicatorY;
            
            // Find intersection with screen boundary
            const centerX = width / 2;
            const centerY = height / 2;
            const maxX = width - margin;
            const maxY = height - margin;
            const minX = margin;
            const minY = margin;
            
            // Calculate where the line intersects the screen boundary
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            
            // Check each edge
            let t = Infinity;
            if (cos > 0) t = Math.min(t, (maxX - centerX) / cos);
            else if (cos < 0) t = Math.min(t, (minX - centerX) / cos);
            if (sin > 0) t = Math.min(t, (maxY - centerY) / sin);
            else if (sin < 0) t = Math.min(t, (minY - centerY) / sin);
            
            indicatorX = centerX + cos * t;
            indicatorY = centerY + sin * t;
            
            // Clamp to screen bounds
            indicatorX = Math.max(margin, Math.min(width - margin, indicatorX));
            indicatorY = Math.max(margin, Math.min(height - margin, indicatorY));
            
            // Calculate distance
            const dist = Math.sqrt((targetX - car.x) ** 2 + (targetY - car.y) ** 2);
            const distDisplay = dist < 1000 ? Math.round(dist) + 'm' : (dist / 1000).toFixed(1) + 'km';
            
            // Create indicator element
            const indicator = document.createElement('div');
            indicator.className = `direction-indicator ${type}${isComplete ? ' complete' : ''}`;
            indicator.style.left = (indicatorX - 20) + 'px';
            indicator.style.top = (indicatorY - 20) + 'px';
            
            // Arrow pointing toward target
            const arrowAngle = angle * 180 / Math.PI;
            indicator.innerHTML = `
                <div class="direction-arrow" style="transform: rotate(${arrowAngle}deg)">‚û§</div>
                <div class="direction-distance">${label ? label + ' ' : ''}${distDisplay}</div>
            `;
            
            container.appendChild(indicator);
        }
        
        // Time trial destination indicator
        if (state.gameMode === 'timeTrial' && state.timeTrialDestination) {
            createIndicator(
                state.timeTrialDestination.x, 
                state.timeTrialDestination.y, 
                'destination', 
                'üèÅ',
                state.timeTrialComplete
            );
        }
        
        // Checkpoint indicators
        if (state.gameMode === 'checkpoint') {
            // Find nearest uncollected checkpoint
            let nearestCheckpoint = null;
            let nearestDist = Infinity;
            
            state.checkpoints.forEach(cp => {
                if (cp.collected) return;
                const dist = Math.sqrt((cp.x - car.x) ** 2 + (cp.y - car.y) ** 2);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearestCheckpoint = cp;
                }
            });
            
            // Show indicator for nearest checkpoint (or all if you prefer)
            if (nearestCheckpoint) {
                createIndicator(
                    nearestCheckpoint.x,
                    nearestCheckpoint.y,
                    'checkpoint',
                    '#' + nearestCheckpoint.index
                );
            }
        }
    }
    function render() {
        const { width, height } = canvas;
        ctx.fillStyle = CONFIG.backgroundColor;
        ctx.fillRect(0, 0, width, height);
        ctx.save();
        ctx.translate(width / 2, height / 2);
        ctx.scale(state.camera.zoom, state.camera.zoom);
        ctx.translate(-state.camera.x, -state.camera.y);
        drawMapTiles();
        drawSkidMarks();
        drawRoads(ctx, false);
        if (state.gameMode === 'checkpoint') drawCheckpoints();
        if (state.gameMode === 'timeTrial') drawTimeTrialDestination();
        drawPolice(ctx);
        drawCar(ctx);
        ctx.restore();
        drawMinimap();
        updateDirectionIndicators();
    }

    function drawSkidMarks() {
        if (state.skidMarks.length === 0) return;
        ctx.fillStyle = CONFIG.skidMarkColor;
        for (let i = state.skidMarks.length - 1; i >= 0; i--) {
            const mark = state.skidMarks[i];
            const alpha = Math.max(0, 0.6 - mark.age * 0.001);
            if (alpha <= 0) { state.skidMarks.splice(i, 1); continue; }
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(mark.x, mark.y, 2, 0, Math.PI * 2);
            ctx.fill();
            mark.age++;
        }
        ctx.globalAlpha = 1;
    }

    function drawRoads(context, isMinimap = false) {
        state.roads.forEach(road => {
            if (road.points.length < 2) return;
            const lineWidth = isMinimap ? 2 : road.width;
            const isCurrentRoad = road === state.car.currentRoad;
            if (!isMinimap) {
                context.strokeStyle = isCurrentRoad ? '#00ffaa' : CONFIG.roadGlow;
                context.lineWidth = lineWidth + 6;
                context.lineCap = 'round';
                context.lineJoin = 'round';
                context.globalAlpha = isCurrentRoad ? 0.35 : 0.15;
                context.beginPath();
                context.moveTo(road.points[0].x, road.points[0].y);
                road.points.slice(1).forEach(p => context.lineTo(p.x, p.y));
                context.stroke();
                context.globalAlpha = 1;
            }
            context.strokeStyle = isMinimap ? (isCurrentRoad ? '#00ffc8' : 'rgba(0, 255, 200, 0.4)') : CONFIG.roadColor;
            context.lineWidth = lineWidth;
            context.beginPath();
            context.moveTo(road.points[0].x, road.points[0].y);
            road.points.slice(1).forEach(p => context.lineTo(p.x, p.y));
            context.stroke();
        });
    }

    function drawCheckpoints() {
        state.checkpoints.forEach(cp => {
            if (cp.collected) return;
            
            // Scale radius inversely with zoom so it stays visible when zoomed out
            const baseRadius = CONFIG.checkpointRadius;
            const minRadius = 12 / state.camera.zoom;
            const radius = Math.max(baseRadius, minRadius);
            
            // Outer glow ring (extra visible when zoomed out)
            ctx.strokeStyle = 'rgba(255, 51, 102, 0.3)';
            ctx.lineWidth = Math.max(10, 6 / state.camera.zoom);
            ctx.beginPath();
            ctx.arc(cp.x, cp.y, radius * 1.3, 0, Math.PI * 2);
            ctx.stroke();
            
            // Outer ring
            ctx.strokeStyle = '#ff3366';
            ctx.lineWidth = Math.max(3, 2 / state.camera.zoom);
            ctx.beginPath();
            ctx.arc(cp.x, cp.y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Inner pulsing
            const pulse = Math.sin(performance.now() / 200) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 51, 102, ${pulse * 0.3})`;
            ctx.beginPath();
            ctx.arc(cp.x, cp.y, radius * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            // Number
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(14, 8 / state.camera.zoom)}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(cp.index, cp.x, cp.y);
        });
    }

    function drawTimeTrialDestination() {
        const dest = state.timeTrialDestination;
        if (!dest) return;
        
        // Scale radius inversely with zoom so it stays visible when zoomed out
        const baseRadius = CONFIG.checkpointRadius * 1.5;
        const minRadius = 15 / state.camera.zoom; // Minimum visible size
        const radius = Math.max(baseRadius, minRadius);
        
        if (state.timeTrialComplete) {
            // Green checkered flag when complete
            ctx.strokeStyle = '#00ff88';
            ctx.lineWidth = Math.max(4, 2 / state.camera.zoom);
            ctx.beginPath();
            ctx.arc(dest.x, dest.y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(0, 255, 136, 0.4)';
            ctx.beginPath();
            ctx.arc(dest.x, dest.y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Larger check mark that scales
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(20, 12 / state.camera.zoom)}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚úì', dest.x, dest.y);
        } else {
            // Pulsing finish flag
            const pulse = Math.sin(performance.now() / 150) * 0.3 + 0.7;
            
            // Outer glow ring (extra visible when zoomed out)
            ctx.strokeStyle = 'rgba(255, 204, 0, 0.3)';
            ctx.lineWidth = Math.max(12, 8 / state.camera.zoom);
            ctx.beginPath();
            ctx.arc(dest.x, dest.y, radius * 1.3, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = Math.max(4, 2 / state.camera.zoom);
            ctx.beginPath();
            ctx.arc(dest.x, dest.y, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.fillStyle = `rgba(255, 204, 0, ${pulse * 0.3})`;
            ctx.beginPath();
            ctx.arc(dest.x, dest.y, radius * pulse, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${Math.max(18, 10 / state.camera.zoom)}px Orbitron`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üèÅ', dest.x, dest.y);
        }
    }

    function drawPolice(context) {
        state.police.forEach(cop => {
            context.save();
            context.translate(cop.x, cop.y);
            context.rotate(cop.angle);
            context.fillStyle = 'rgba(0, 0, 0, 0.4)';
            context.beginPath();
            context.roundRect(-cop.width/2 + 2, -cop.height/2 + 2, cop.width, cop.height, 2);
            context.fill();
            context.shadowColor = cop.isChasing ? '#ffffff' : '#666666';
            context.shadowBlur = cop.isChasing ? 15 : 5;
            context.fillStyle = '#111111';
            context.beginPath();
            context.roundRect(-cop.width/2, -cop.height/2, cop.width, cop.height, 2);
            context.fill();
            context.fillStyle = '#eeeeee';
            context.beginPath();
            context.roundRect(0, -cop.height/2, cop.width/2, cop.height, [0, 2, 2, 0]);
            context.fill();
            if (cop.isChasing) {
                const sirenTime = cop.sirenPhase;
                const redOn = Math.sin(sirenTime) > 0;
                const blueOn = Math.sin(sirenTime + Math.PI) > 0;
                context.shadowColor = '#ff0000';
                context.shadowBlur = redOn ? 20 : 5;
                context.fillStyle = redOn ? '#ff0000' : '#660000';
                context.beginPath();
                context.arc(-cop.width/6, 0, 2, 0, Math.PI * 2);
                context.fill();
                context.shadowColor = '#0066ff';
                context.shadowBlur = blueOn ? 20 : 5;
                context.fillStyle = blueOn ? '#0066ff' : '#000066';
                context.beginPath();
                context.arc(cop.width/6, 0, 2, 0, Math.PI * 2);
                context.fill();
            }
            context.shadowBlur = 10;
            context.shadowColor = '#ffffff';
            context.fillStyle = '#ffffff';
            context.beginPath();
            context.arc(cop.width/2 - 1, -cop.height/4, 1.5, 0, Math.PI * 2);
            context.arc(cop.width/2 - 1, cop.height/4, 1.5, 0, Math.PI * 2);
            context.fill();
            context.restore();
        });
    }

    function drawCar(context) {
        const car = state.car;
        context.save();
        context.translate(car.x, car.y);
        context.rotate(car.angle);
        context.fillStyle = 'rgba(0, 0, 0, 0.4)';
        context.beginPath();
        context.roundRect(-car.width/2 + 3, -car.height/2 + 3, car.width, car.height, 3);
        context.fill();
        context.shadowColor = CONFIG.carColor;
        context.shadowBlur = car.isSkidding ? 30 : 20;
        context.fillStyle = CONFIG.carColor;
        context.beginPath();
        context.roundRect(-car.width/2, -car.height/2, car.width, car.height, 3);
        context.fill();
        context.fillStyle = 'rgba(100, 200, 255, 0.4)';
        context.beginPath();
        context.roundRect(car.width/6, -car.height/3, car.width/4, car.height/1.5, 1);
        context.fill();
        context.shadowBlur = 15;
        context.shadowColor = '#ffffff';
        context.fillStyle = '#ffffff';
        context.beginPath();
        context.arc(car.width/2 - 2, -car.height/3, 2.5, 0, Math.PI * 2);
        context.arc(car.width/2 - 2, car.height/3, 2.5, 0, Math.PI * 2);
        context.fill();
        context.shadowColor = '#ff0000';
        context.shadowBlur = car.isBraking ? 25 : 10;
        context.fillStyle = car.isBraking ? '#ff3333' : '#aa0000';
        context.beginPath();
        context.arc(-car.width/2 + 2, -car.height/3, 2, 0, Math.PI * 2);
        context.arc(-car.width/2 + 2, car.height/3, 2, 0, Math.PI * 2);
        context.fill();
        context.restore();
    }

    function drawMinimap() {
        const mctx = minimapCtx, { width, height } = minimapCanvas;
        mctx.fillStyle = 'rgba(10, 10, 15, 0.95)';
        mctx.fillRect(0, 0, width, height);
        if (!state.bounds) return;
        const scale = 0.15;
        const cx = width/2, cy = height/2;
        const car = state.car;
        
        // Roads
        mctx.save();
        mctx.translate(cx, cy);
        drawRoads(mctx, true);
        
        // Checkpoints on minimap
        if (state.gameMode === 'checkpoint') {
            state.checkpoints.forEach(cp => {
                if (cp.collected) return;
                const x = (cp.x - car.x) * scale;
                const y = (cp.y - car.y) * scale;
                mctx.fillStyle = '#ff3366';
                mctx.beginPath();
                mctx.arc(x, y, 4, 0, Math.PI * 2);
                mctx.fill();
            });
        }
        
        // Time trial destination on minimap
        if (state.gameMode === 'timeTrial' && state.timeTrialDestination) {
            const dest = state.timeTrialDestination;
            const x = (dest.x - car.x) * scale;
            const y = (dest.y - car.y) * scale;
            mctx.fillStyle = state.timeTrialComplete ? '#00ff88' : '#ffcc00';
            mctx.beginPath();
            mctx.arc(x, y, 6, 0, Math.PI * 2);
            mctx.fill();
        }
        
        mctx.restore();
        
        // Car (center)
        mctx.save();
        mctx.translate(cx, cy);
        mctx.rotate(car.angle);
        mctx.fillStyle = CONFIG.carColor;
        mctx.beginPath();
        mctx.moveTo(8, 0);
        mctx.lineTo(-5, -4);
        mctx.lineTo(-5, 4);
        mctx.closePath();
        mctx.fill();
        mctx.restore();
    }

    // ============== GAME LOOP ==============
    function gameLoop(currentTime) {
        if (!state.gameStarted) return;
        if (state.gamePaused) return;
        
        const dt = Math.min((currentTime - state.lastTime) / 1000, 0.05);
        state.lastTime = currentTime;
        
        update(dt);
        render();
        
        requestAnimationFrame(gameLoop);
    }

    // ============== EVENT SETUP ==============
    function setupEvents() {
        // Keyboard
        window.addEventListener('keydown', e => {
            state.keys[e.code] = true;
            if (e.code === 'Escape') {
                if (state.gamePaused) resumeGame();
                else pauseGame();
            }
            if ((e.code === 'Equal' || e.code === 'NumpadAdd') && state.gameStarted) {
                state.camera.manualZoom = true;
                state.camera.targetZoom = Math.min(CONFIG.maxCameraZoom, state.camera.targetZoom * 1.15);
            }
            if ((e.code === 'Minus' || e.code === 'NumpadSubtract') && state.gameStarted) {
                state.camera.manualZoom = true;
                state.camera.targetZoom = Math.max(CONFIG.minCameraZoom, state.camera.targetZoom / 1.18);
            }
            if (e.code === 'KeyR' && state.gameStarted && !state.gamePaused) {
                state.camera.manualZoom = false;
                state.camera.targetZoom = CONFIG.baseCameraZoom;
            }
        });
        window.addEventListener('keyup', e => { state.keys[e.code] = false; });
        
        // Mouse
        let isDragging = false, lastMouseX, lastMouseY;
        canvas.addEventListener('mousedown', e => { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; });
        window.addEventListener('mouseup', () => { isDragging = false; });
        window.addEventListener('mousemove', e => {
            if (isDragging && state.gameStarted) {
                state.camera.x -= (e.clientX - lastMouseX) / state.camera.zoom;
                state.camera.y -= (e.clientY - lastMouseY) / state.camera.zoom;
                lastMouseX = e.clientX; lastMouseY = e.clientY;
            }
        });
        canvas.addEventListener('wheel', e => {
            if (!state.gameStarted) return;
            e.preventDefault();
            state.camera.manualZoom = true;
            const zoomFactor = e.deltaY > 0 ? 0.85 : 1.18;
            state.camera.targetZoom = Math.max(CONFIG.minCameraZoom, Math.min(CONFIG.maxCameraZoom, state.camera.targetZoom * zoomFactor));
        }, { passive: false });
        
        // Resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Title screen
        document.querySelectorAll('.location-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.location-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                CONFIG.currentLocation = btn.dataset.location;
            });
        });
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                state.gameMode = btn.dataset.mode;
            });
        });
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('howToPlayBtn').addEventListener('click', e => {
            e.preventDefault();
            document.getElementById('howToPlay').classList.add('visible');
        });
        document.getElementById('closeHelp').addEventListener('click', () => {
            document.getElementById('howToPlay').classList.remove('visible');
        });
        
        // Pause menu
        document.getElementById('resumeBtn').addEventListener('click', resumeGame);
        document.getElementById('restartBtn').addEventListener('click', restartGame);
        document.getElementById('helpBtn').addEventListener('click', () => {
            document.getElementById('howToPlay').classList.add('visible');
        });
        document.getElementById('mainMenuBtn').addEventListener('click', goToMainMenu);
        
        // Results
        document.getElementById('playAgainBtn').addEventListener('click', restartGame);
        document.getElementById('resultsMenuBtn').addEventListener('click', goToMainMenu);
        
        // In-game buttons
        document.getElementById('locationBtn').addEventListener('click', () => {
            const newLoc = CONFIG.currentLocation === 'baltimore' ? 'hollywood' : 'baltimore';
            CONFIG.currentLocation = newLoc;
            CONFIG.startLat = LOCATIONS[newLoc].lat;
            CONFIG.startLon = LOCATIONS[newLoc].lon;
            document.getElementById('locationBtn').textContent = 'üìç ' + (newLoc === 'baltimore' ? 'Hollywood' : 'Baltimore');
            document.getElementById('locationValue').textContent = LOCATIONS[newLoc].name;
            loadRoads();
        });
        document.getElementById('mapToggleBtn').addEventListener('click', () => {
            state.mapType = state.mapType === 'satellite' ? 'street' : 'satellite';
            document.getElementById('mapToggleBtn').textContent = state.mapType === 'satellite' ? 'üó∫Ô∏è Street View' : 'üõ∞Ô∏è Satellite';
        });
        document.getElementById('policeBtn').addEventListener('click', () => {
            state.policeEnabled = !state.policeEnabled;
            document.getElementById('policeBtn').classList.toggle('active', state.policeEnabled);
            if (state.policeEnabled) spawnPolice();
            else state.police = [];
        });
        document.getElementById('respawnBtn').addEventListener('click', respawnCar);
        document.getElementById('reloadBtn').addEventListener('click', () => {
            state.tiles = {};
            loadRoads();
        });
    }

    // ============== INIT ==============
    setupEvents();
    </script>
</body>
</html>
